<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器触觉</title>
    <link href="/henry.github.io/2025/06/26/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/"/>
    <url>/henry.github.io/2025/06/26/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/</url>
    
    <content type="html"><![CDATA[<p>去年在视触觉方向调研看综述，总觉得这项技术不会是最终的触觉解决方案</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/%E8%A7%86%E8%A7%A6%E8%A7%891.png?raw=true" alt="视触觉1"><br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/%E8%A7%86%E8%A7%A6%E8%A7%892.png?raw=true" alt="视触觉2"></p><p>毕竟本身受限于相机传感器的大小和分辨率，同时还需要再对图像进行处理最后获得向量，中间还涉及到标记层，反射层，形变层的区分，制备，总是有一种绕弯子的感觉，主要是觉得这个尺度下的触觉传感器应该最终不会成为主流，当时更倾向于压电式或电容式方案；</p><p>后来继续查资料过程中了解到张一慧教授课题组的柔电皮肤的工作，为这种巧妙的力传感单元设计所惊讶，觉得更符合对人类皮肤的模仿，能直接从物理层面解耦地测量压力、剪切力、形变。</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/%E5%BC%A0%E4%B8%80%E6%85%A71.png?raw=true" alt="张一慧1"></p><p>最主要是觉得抛开图像传感器的大小和分辨率限制，能有更高的敏感度，数据处理仍然需要结合深度学习算法（什么时候能实现从电信号直接完成处理，可能更类似于模拟信号处理，我认为会极大提高视觉、语言、触觉的感知效率，这也是先前我对机器人的脊髓或者说是整个中枢神经系统的构想核心观点），可能在计算方面看不到太多优势所在。但总之这样的方案更符合我心中的机器触觉的方案吧；</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/%E5%BC%A0%E4%B8%80%E6%85%A72.png?raw=true" alt="张一慧2"></p><p>这两天又了解到矩侨工业的柔性纤维传感器，看到他们做的机器人皮肤和演示，很是震撼：柔性，可变性，优秀的分辨率，覆盖率，压力测量敏感度，都完美符合我对电子皮肤的想象。</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/jq1.png?raw=true" alt="矩侨1"></p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E6%9C%BA%E5%99%A8%E8%A7%A6%E8%A7%89/jq2.png?raw=true" alt="矩侨2"></p><p>矩侨自己称之为“纤维电阻式”方案。相比视触觉方案，后述两种方案，我认为更符合人类利用生物电实现触觉的本质（好奇怪的说法）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sincerely</title>
    <link href="/henry.github.io/2025/05/12/Sincerely/"/>
    <url>/henry.github.io/2025/05/12/Sincerely/</url>
    
    <content type="html"><![CDATA[<p>你永远无法真正揣测一个人的心思，因为人心比迷宫更曲折——有时连自己都找不到出口。</p><p>那些高喊渴望真诚的人，往往最精于表演；</p><p>那些追求纯粹爱情观的人，转身投身于最混乱的关系里；</p><p>那些把‘为别人着想’挂在嘴边的人，往往最熟练地计算着得失。&quot;</p><p>那些说着厌恶虚伪的人，活得最像笑话。</p><p>我们擅长把空洞说成信仰，把私欲粉饰成善良，把自私包装成深情。</p><p>别天真了。人不会轻易坦白，人只会小心翼翼地塑造一个体面又虚假的自己。</p><p>人类最矛盾的浪漫，就在于我们一边用语言搭建灯塔，一边用行动制造迷雾。</p><p>You can never truly fathom a person’s mind, because the human heart is more twisted than any maze—sometimes even we ourselves can’t find the exit.</p><p>Those who loudly proclaim their longing for sincerity are often the most skilled performers;</p><p>Those who preach about pure love are the ones who plunge into the messiest relationships;</p><p>Those who keep “thinking of others” on their lips are often the ones who calculate gains and losses most precisely;</p><p>Those who claim to despise hypocrisy often end up living as the biggest jokes.</p><p>We are masters at dressing emptiness as conviction, disguising selfishness as kindness, and wrapping greed as affection.</p><p>Don’t be naïve. People rarely confess willingly—they only carefully sculpt a respectable yet hollow facade.</p><p>The most contradictory romance of humanity lies in this: we build lighthouses with our words, yet shroud everything in fog with our actions.</p>]]></content>
    
    
    
    <tags>
      
      <tag>诗歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字系统设计-第二周</title>
    <link href="/henry.github.io/2024/11/22/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
    <url>/henry.github.io/2024/11/22/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<h1>补码</h1><p>2’s Complement</p><ul><li>正数的补码与原码一致</li><li>负数补码：将正数原码按位取反然后加一，超过原长度的位丢弃</li></ul><h1>Adder加法器</h1><h2 id="Half-Adders">Half Adders</h2><p><img src="/henry.github.io/henry.github.io/2024/11/22/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E5%91%A8/img.png" alt="img.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高级网络编程-第二周-HTML</title>
    <link href="/henry.github.io/2024/10/28/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E5%91%A8-HTML/"/>
    <url>/henry.github.io/2024/10/28/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E5%91%A8-HTML/</url>
    
    <content type="html"><![CDATA[<p>HTML全称:</p><p>Hyper Text Markup Language</p><hr><p>基本格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        This is my first homepage<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1>HTML 标签(初级)</h1><table><thead><tr><th>Tags</th><th>Role</th></tr></thead><tbody><tr><td>&lt;html&gt; &lt;/html&gt;</td><td>Defines an HTML document</td></tr><tr><td>&lt;head&gt; &lt;/head&gt;</td><td>Defines the document’s body</td></tr><tr><td>&lt;title&gt; &lt;/title&gt;</td><td>Defines the document’s title</td></tr><tr><td>&lt;p&gt; &lt;/p&gt;</td><td>Paragraphs</td></tr><tr><td>&lt;h&gt; &lt;/h&gt;</td><td>Headings</td></tr><tr><td>&lt;br /&gt;</td><td>Line Breaks</td></tr><tr><td>&lt;hr&gt;</td><td>Horizontal rule</td></tr><tr><td>&lt;!-- comment --&gt;</td><td>Comment</td></tr></tbody></table><h2 id="HTML-属性-文本格式">HTML 属性/文本格式</h2><ul><li>Attribute 属性为HTML元素提供一个额外信息，就类似于Java方法中的参数</li><li>这些参数为元素的可选项提供了值，例如选择字符位置，字体大小，背景颜色等<br>举例：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span> heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;yellow&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性和属性值都是大小写不敏感的</p><h2 id="HTML-Text-Formatting">HTML Text Formatting</h2><table><thead><tr><th>Tags</th><th>Role</th></tr></thead><tbody><tr><td>&lt;b&gt;</td><td>Blod text</td></tr><tr><td>&lt;big&gt;</td><td>Big text</td></tr><tr><td>&lt;em&gt;</td><td>Emphasized text 斜体强调</td></tr><tr><td>&lt;i&gt;</td><td>Italic text 斜体</td></tr><tr><td>&lt;small&gt;</td><td>Small text</td></tr><tr><td>&lt;strong&gt;</td><td>Defines strong text</td></tr><tr><td>&lt;sub&gt;</td><td>Defines subcripted text 下标文本</td></tr><tr><td>&lt;sup&gt;</td><td>Defines superscripted text 上标文本</td></tr><tr><td>&lt;ins&gt;</td><td>Inserted text</td></tr><tr><td>&lt;sel&gt;</td><td>Deleted test</td></tr></tbody></table><h3 id="i-vs-em">&lt;i&gt; vs. &lt;em&gt;</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">新的开发人员看到多个元素产生相似的效果，经常被混淆。&lt;em&gt; 和 &lt;i&gt; 就是一对常见的例子，因为它们都对文字斜体化。它们的区别是什么？应该使用哪一个？<br><br>在默认情况下，它们的视觉效果是一样的。但语义是不同的。 &lt;em&gt; 标签表示其内容的着重强调，而 &lt;i&gt; 标签表示从正常散文中区分出的文本，例如外来词，虚构人物的思想，或者当文本指的是一个词语的定义，而不是其语义含义。（作品的标题，例如书籍或电影的名字，应该使用 &lt;cite&gt;。）<br><br>这意味着，正确使用哪一个取决于具体的场景。两者都不是纯粹为了装饰的目的，那是 CSS 样式所做的。<br><br>一个 &lt;em&gt; 的例子可能是：&quot;Just do it already!&quot;，或：&quot;We had to do something about it&quot;。人或软件在阅读文本时，会对斜体字的发音使用重读强调。<br><br>一个 &lt;i&gt; 的例子可能是：&quot;The Queen Mary sailed last night&quot;。在这里，没有对 &quot;Queen Mary&quot; 这个词添加强调或重要性。它只是表明，谈论的对象不是一个名叫玛丽的女王，而是一艘名字叫玛丽的船。另一个 &lt;i&gt; 的例子可能是：&quot;The word the is an article&quot;。<br></code></pre></td></tr></table></figure><h3 id="Bold-vs-Strong">Bold vs. Strong</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">新的开发者经常感到疑惑，为什么在一个渲染的网站上会有这么多方式来表达同样的东西。Bold 和 Strong 可能就是这其中的一种。为什么使用&lt;strong&gt;&lt;/strong&gt;而不是&lt;b&gt;&lt;/b&gt;? 使用 strong 的话你不得不打更多的字母，却产生出和 b 同样的效果，对吧？<br><br>也许并不是；strong 是一个逻辑状态，而 bold 是一个物理状态。逻辑状态分离内容和表现形式，使用逻辑状态允许你用各种不同的方式来表达。比如你想把文字渲染成红色，使用其他大小的字体、带有下划线或其他样式，而不是加粗的样式。必须要理解使用 strong 呈现出的表现形式不同于单纯的加粗。因为 bold 是一个物理状态，他没有区分表现形式和内容。如果让 bold 做了加粗文本外的其他任何事情，都将会令人困惑而且也不符合逻辑。<br><br>同样应该注意&lt;b&gt;&lt;/b&gt; 还有其他用途，比如想单纯地吸引注意而不增加其重要性。<br></code></pre></td></tr></table></figure><h3 id="Emphasis-vs-Strong">Emphasis vs. Strong</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在 HTML4 时，Strong 简单地表示一个更强的强调 (emphasis)，而在 HTML5 中，这个元素被描述为表征“内容强烈的重要性 (strong importance for its contents) ”。这是一个重要的区别。Em 标签 (Emphasis) 用于改变一个句子的意思 (比如&quot;我&lt;em&gt;*喜欢&lt;/em&gt;*胡萝卜&quot; 和&quot;我喜欢&lt;em&gt;胡萝卜&lt;/em&gt;&quot;，分别强调喜欢和胡萝卜), Strong 用来对一个句子的部分增加重要性 (比如 &quot;警告！ 这非常危险。&quot;) Strong 和 Emphasis 都可以分别通过嵌套来增加相对重要性或强调重点。<br></code></pre></td></tr></table></figure><h2 id="符号文本">符号文本</h2><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E5%91%A8-HTML/img.png?raw=true" alt></p><h2 id="HTML-Links">HTML Links</h2><ul><li>HTML 可以使用超链接链接到web的其它document</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“linkpage.html”</span>&gt;</span>This text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> is a link to a page on   <br>this Web site.<br><br> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“http://www.qmul.ac.uk/”</span>&gt;</span>This text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> is a link to <br>QMUL<br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Use an image as a link:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“linkpage.htm”</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">border</span>=<span class="hljs-string">“0”</span></span><br><span class="hljs-tag">                                <span class="hljs-attr">src</span>=<span class="hljs-string">“image.jpg”</span> <span class="hljs-attr">width</span>=<span class="hljs-string">“65”</span> <span class="hljs-attr">height</span>=<span class="hljs-string">“38”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.qmul.ac.uk/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>Visit QMUL<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="http://www.qmul.ac.uk/">This text</a> is a link to<br>QMUL</p><p> Use an image as a link:  <a href="linkpage.html"><img border="0" src="/henry.github.io/henry.github.io/2024/10/28/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E5%91%A8-HTML/image.jpg" width="65" height="38"></a> </p><p><a href="http://www.qmul.ac.uk/#primary-nav-about" target="_blank">Visit QMUL</a></p><p>如果省略了http字符，我们会在本地的路径去寻找url，而不是互联网</p><h3 id="target">target</h3><p>target选项</p><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>_blank</td><td>Opens the linked document in a new window or tab</td></tr><tr><td>_self</td><td>Opens the linked document in the same frame as it was clicked (this is default)</td></tr><tr><td>_parent</td><td>Opens the linked document in the parent frame</td></tr><tr><td>_top</td><td>Opens the linked document in the full body of the window</td></tr><tr><td>framename</td><td>Opens the linked document in a named frame</td></tr></tbody></table><h2 id="HTML-Tables">HTML Tables</h2><p>这是一个简单的HTML表格示例</p><table border="1" bgcolor="#6495ed">    <tr>        <td>row 1, cell 1</td>        <td>row 1, cell 2</td>    </tr>    <tr>        <td>row 2, cell 1</td>        <td>row 2, cell 2</td>    </tr>    <tr>       <td align="“left”">To left</td>       <td align="“right”">To right</td>       <td align="“center”">To center</td>    </tr></table><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;#ff7f50&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">“left”</span>&gt;</span>To left<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">“right”</span>&gt;</span>To right<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">“center”</span>&gt;</span>To center<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="table相关tags">table相关tags</h3><ul><li>&lt;table&gt; Defines a table</li><li>&lt;th&gt; Defines a table header</li><li>&lt;tr&gt; Defines a table row</li><li>&lt;td&gt; Defines a table cell.</li><li>&lt;caption&gt; Defines a table caption.</li><li>&lt;thead&gt; Defines a table head.</li><li>&lt;tbody&gt; Defines a table body.</li><li>&lt;tfoot&gt; Defines a table footer.</li></ul><h2 id="HTML-Lists">HTML Lists</h2><p>列表，分为无序列表，有序列表</p><ul> <li>Coffee</li> <li>Tea</li> <li>Milk</li> </ul> <ol> <li>Coffee</li> <li>Tea</li> <li>Milk</li> </ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有序列表还分为几种不同排序格式</p><ol type="A"> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><ol type="a"> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><ol type="I"> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><ol type="i"> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;I&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-Images-Colour">HTML Images &amp; Colour</h2><p>插入图像标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.gif&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;144&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;me.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;This is me&quot;</span>&gt;</span><br>alt 标签用于定义图像的替代文本（alternate text）<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;background.jpb&quot;</span>&gt;</span><br>设置背景图<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;#d0d0d0&quot;</span>&gt;</span><br>设置背景图颜色<br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;#6495ed&quot;</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;yellow&quot;</span>&gt;</span><br>设置字体颜色<br></code></pre></td></tr></table></figure><h1>处理表单与输入</h1><ul><li>HTML 表单（Forms） 用于选择不同的用户输入</li><li>表单是一个可以允许用户输入信息的表单元素区域<ul><li>包括： text fields, textarea fields, drop-down menus, radio buttons, checkboxes</li></ul></li><li>最常用的表单标签是&lt;input&gt;标签，输入的具体形式，由type属性决定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Text-fields-Password-Fields">Text fields &amp; Password Fields</h2> <form action> First name: <input type="text" name="firstname"> <br> Last name: <input type="text" name="lastname"> </form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    First name: <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">name</span>=<span class="hljs-string">“firstname”</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    Last name:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastname&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form action>  Username:  <input type="text" name="user">  <br>  Password:  <input type="password" name="password"></form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  Username:<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Password:<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>name属性是向服务器提交表单时所发送的标识符，相当于是一个变量名</p><p>password type的输入，当我们在框内输入时，会隐藏我们的输入</p><h2 id="Radio-buttons-Checkboxes">Radio buttons &amp; Checkboxes</h2> <form>  <input type="radio" name="sex" value="male"> Male  <br>  <input type="radio" name="sex" value="female"> Female </form> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> Male<br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> Female<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure> <form>  I have a bike:  <input type="checkbox" name="vehicle" value="Bike">  <br>  I have a car:   <input type="checkbox" name="vehicle" value="Car">  <br>  I have an airplane:   <input type="checkbox" name="vehicle" value="Airplane"> </form> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br> I have a bike:<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">“checkbox”</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">“vehicle”</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">“Bike”</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> I have a car: <br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">“checkbox”</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">“Car”</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> I have an airplane: <br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">“checkbox”</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">“vehicle”</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">value</span>=<span class="hljs-string">“Airplane”</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>name相当于变量名，value是这个选项的值，相当于为变量赋值</p><h2 id="label-Button">&lt;label&gt; Button</h2><ul><li>每个按钮都应该有一个label</li><li>&lt;label&gt; tag为一个输入元件定义了一个标签</li><li>label tag允许用户像按钮一样按下label</li></ul><p>&lt;label&gt; 的for 属性的值是与之相关的表单元素的id:</p><form action="demo_form.asp">  <label for="male"> Male </label>  <input type="radio" name="sex" id="male" value="male"><br>  <label for="female">Female</label>  <input type="radio" name="sex" id="female" value="female"><br>  <input type="submit" value="Submit"></form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo_form.asp&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> Male <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>Female<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="action-属性和-submit-按钮">action 属性和 submit 按钮</h2><p>当用户按下Submit按钮，表单内容将会被发送到另一个文件</p><p>表单的action属性是定义要发送的目的文件名</p><p>action属性中定义的文件会对接收的输入做处理</p><form name="input" action="html_form_action.jsp" method="get">  Username:  <input type="text" name="user">  <input type="submit" value="Submit"></form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;html_form_action.jsp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  Username:<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form action="https://www.baidu.com/s" method="get">  <input type="text" name="wd"> <br>  <input type="submit" value="百度一下"></form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://www.baidu.com/s&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wd&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;百度一下&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>method属性即我们http中的请求方法，这里我们是要获取资源，因此调用get method</p><p>wd是URL参数名，是百度用于搜索关键字的</p><p>当我们提交表单，会有类似下面的格式提交给web服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://www.baidu.com/s?wd=123<br></code></pre></td></tr></table></figure><p>?后面跟着url参数及其值，123是我们的搜索关键字</p><h2 id="将图像作为提交按钮">将图像作为提交按钮</h2><input type="image" name="submit" src="cat.jpg"><h2 id="下拉框-字段组">下拉框 &amp; 字段组</h2> <form action>  <select name="cars">    <option value="volvo">Volvo</option>    <option value="saab">Saab</option>    <option value="fiat">Fiat</option>    <option value="audi">Audi</option>  </select> </form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;saab&quot;</span>&gt;</span>Saab<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;audi&quot;</span>&gt;</span>Audi<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><fieldset>  <legend>    Health information:  </legend>  <form action>    Height <input type="text" size="3">    Weight <input type="text" size="3">  </form></fieldset><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span><br>    Health information:<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    Height <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>    Weight <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="文本域-按钮">文本域 &amp; 按钮</h2><textarea rows="10" cols="30"> The cat was playing in the garden.</textarea> <form action> <input type="button" value="Hello world!"> </form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br> The cat was playing in the garden.<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello world!&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="button-submit差别">button &amp; submit差别</h3><ul><li><p>&lt;input type=“button” value=“button”&gt;</p><p><input type="button" value="button"> button类型不会主动提交表单，默认不执行动作，需要js部分实现功能</p></li><li><p>&lt;input type=“submit”&gt;</p><p><input type="submit"> submit类型当点击时会提交一个表单</p><p>不过具体情况也会根据不同的浏览器有所不同</p></li><li><p>4种“按钮”</p></li></ul><input type="submit" value="type1"><input type="button" value="type2"><button type="button">type3</button><button type="submit">type4</button><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;type1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;type2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>type3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>type4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所有submit类型的按钮，都可以用作提交表单，而button类型按钮，不可以，默认不做任何动作</p><p>一个表单示例：发送邮件</p><form action="MAILTO:mailname@company.com" method="post" enctype="text/plain">  Name:<br>  <input type="text" name="name" size="20">  <br>  Mail:<br>  <input type="text" name="mail" size="20">  <br>  Comment:<br>  <input type="text" name="comment" size="40">  <br><br>  <input type="submit" value="Send">  <input type="reset" value="Reset"></form> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;MAILTO:mailname@company.com&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;text/plain&quot;</span>&gt;</span><br>  Name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Mail:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mail&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Comment:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;comment&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;40&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Send&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Reset&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>reset类型，可以重置表单填写</p><h3 id="id-name-属性的不同">id &amp; name 属性的不同</h3><ul><li>name属性相当于是我们提交表单时的变量名，id属性是html页面的元素标识符</li></ul><form id="“gender_form”"> <input type="radio" name="sex" value="male"> Male <br> <input type="radio" name="sex" value="female"> Female </form> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">“gender_form”</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> Male<br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> Female<br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure> <form id="register"> <h1>Register for Miss Bakers Space Cadets</h1> <fieldset> <legend>Personal details</legend> <div> <label>First Name <input id="given-name" name="given-name" type="text" placeholder="First name only" required autofocus> </label> </div> <div> <label>Last Name <input id="family-name" name="family-name" type="text" placeholder="Last name only" required autofocus> </label> </div> </fieldset> </form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;register&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Register for Miss Bakers Space Cadets<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Personal details<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>First Name<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;given-name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;given-name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;First name only&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">autofocus</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Last Name<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;family-name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family-name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Last name only&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">autofocus</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单相关的tag">表单相关的tag</h3><ul><li>&lt;form&gt; Defines a form for user input.</li><li>&lt;input&gt; Defines an input field.</li><li>&lt;textarea&gt; Defines a text-area.</li><li>&lt;label&gt; Defines a label to a control.</li><li>&lt;fieldset&gt; Defines a fieldset.</li><li>&lt;legend&gt; Defines a caption for a fieldset.</li><li>&lt;select&gt; Defines a selectable list (a drop-down box).</li><li>&lt;optgroup&gt; Defines an option group.</li><li>&lt;option&gt; Defines an option in the drop-down box.</li><li>&lt;button&gt; Defines a push button</li></ul><h2 id="HTML5标准下的页面结构">HTML5标准下的页面结构</h2><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E5%91%A8-HTML/img_1.png?raw=true" alt></p><h2 id="CSS">CSS</h2><p>CSS(cascading style sheets)层叠样式表</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>高级网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>高级网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VHDL（三）Testbench与仿真</title>
    <link href="/henry.github.io/2024/09/28/VHDL-Testbench%E4%B8%8E%E4%BB%BF%E7%9C%9F/"/>
    <url>/henry.github.io/2024/09/28/VHDL-Testbench%E4%B8%8E%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><ul><li>前面两篇文章我们已经介绍了VHDL的基本语法和基本模块的编写要点</li><li>但是光有模块和构建好的architecture还不行，我们还需要对电路提供信号激励，也就是数字电路系统的输入，这样才能使得电路系统真正工作起来。</li><li>本篇文章开始介绍如何编写系统激励，并且讲述如何使用VHDL仿真</li></ul><p>前面两篇文章连接：</p><ol><li>VHDL基础学习：</li></ol><p><a href="https://jhr419.github.io/henry.github.io/2024/09/27/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">https://jhr419.github.io/henry.github.io/2024/09/27/VHDL基础学习/</a></p><ol start="2"><li>VHDL电路模型：</li></ol><p><a href="https://jhr419.github.io/henry.github.io/2024/09/28/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/">https://jhr419.github.io/henry.github.io/2024/09/28/VHDL电路模型/</a></p><h1>VHDL中的标准模型</h1><ul><li>目前，我们已经学习了三种类型的信号赋值：并发，条件(when-else)，选择(with-select)</li><li>接下来我们将看到另一种并发语句，时序语句sequential statement</li><li>描述VHDl的architecture有很多种标准模型和方式<ul><li>data-flow style, structural style, behavioral style</li></ul></li></ul><p>关于三种类型的详解可见：<br><a href="https://buzztech.in/vhdl-modelling-styles-behavioral-dataflow-structural/">https://buzztech.in/vhdl-modelling-styles-behavioral-dataflow-structural/</a></p><h2 id="Data-Flow-Style-结构">Data-Flow Style 结构</h2><ul><li>数据流风格：通过显示系统各种内置组件之间的输入输出来描述电路</li><li>组件包括：常用逻辑运算操作符，复用器，解码器等</li></ul><p>在之前我们写过的例子中你可以看到数据流风格是如何工作的<br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL-Testbench%E4%B8%8E%E4%BB%BF%E7%9C%9F/img.png?raw=true" alt></p><h2 id="Behavioral-Style-结构">Behavioral Style 结构</h2><ul><li>随着电路变得复杂起来，最好还是选择行为风格</li><li>behavioral style会简化实际硬件实现设计，重点关注电路如何对输入做出反应产生输出</li><li>可以将更多的细节实现留给合成器</li></ul><h2 id="Process-Statement-过程语句">Process Statement 过程语句</h2><ul><li>行为风格的核心是process statement</li><li>由一个或多个过程语句组成，每个语句是一个独立的并发语句，它本身包含一个或多个顺序语句</li><li>顺序语句由仿真器按顺序执行，这与传统编程语言中的顺序语句执行相同</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs VHDL">my_label: <span class="hljs-keyword">process</span>(sensitivity_list) <span class="hljs-keyword">is</span><br>    &lt;item declaration&gt;<br><span class="hljs-keyword">begin</span><br>    &lt;sequential_statements&gt;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> my_label;<br></code></pre></td></tr></table></figure><p>与数据流风格对比：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> my_xor <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span> ( A, B : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>       F    : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> my_xor;<br><span class="hljs-keyword">architecture</span> dataflow <span class="hljs-keyword">of</span> my_xor <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  F &lt;= A <span class="hljs-keyword">xor</span> B;<br><span class="hljs-keyword">end</span> dataflow;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">architecture</span> behav <span class="hljs-keyword">of</span> my_xor <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  xor_proc: <span class="hljs-keyword">process</span> (A, B)<br>  <span class="hljs-keyword">begin</span><br>    F &lt;= A <span class="hljs-keyword">xor</span> B;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> xor_proc;<br><span class="hljs-keyword">end</span> behav;<br></code></pre></td></tr></table></figure><ul><li><p>这里的<strong>xor_proc</strong>是process的实例化</p></li><li><p>区别：</p><ul><li>数据流风格代码直接通过并行信号赋值来描述逻辑。<br>Sum &lt;= A xor B; 和 Carry &lt;= A and B;<br>是独立的并行操作。</li><li>过程风格代码在 process 块中使用。<br>这里的操作是顺序的，但在 process 中由敏感列表 (A, B) 控制，只要 A 或 B 发生变化，进程就会执行。</li></ul></li></ul><h3 id="D触发器">D触发器</h3><ul><li>用D触发器的例子来介绍两种风格的显著区别</li></ul><p>D触发器是一种典型的时序逻辑电路，它在时钟信号的上升沿时存储输入信号</p><ul><li>数据流风格：无法直接实现时序逻辑，因为它不能处理时钟触发</li><li>过程风格：可以使用时钟事件来控制信号存储的时序逻辑</li></ul><ol><li>数据流风格<br>数据流风格是用于描述组合逻辑的，它无法实现需要时钟触发的电路，比如 D 触发器。我们无法用数据流风格直接描述 D 触发器的行为，因为它缺少对时钟沿（如上升沿）的控制。</li></ol><p>数据流风格更适合描述逻辑运算，而不是时钟控制的电路。你可能会尝试像下面这样写，但它是错误的，因为无法通过组合逻辑实现时序行为：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">-- 无法用数据流风格实现 D 触发器</span><br><span class="hljs-keyword">architecture</span> dataflow <span class="hljs-keyword">of</span> d_flip_flop <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">-- 错误示例：没有时钟沿控制</span><br>    Q &lt;= D; <span class="hljs-comment">-- 无法触发时序逻辑，只会产生组合逻辑</span><br><span class="hljs-keyword">end</span> dataflow;<br></code></pre></td></tr></table></figure><ol start="2"><li>过程风格（适合时序逻辑）</li></ol><p>过程风格可以使用时钟的上升沿来触发信号的变化，这就是时序电路的典型应用。</p><p>下面是一个用 过程风格 编写的 D 触发器代码：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span>;<br><br><span class="hljs-comment">-- 实体定义</span><br><span class="hljs-keyword">entity</span> d_flip_flop <span class="hljs-keyword">is</span><br>    <span class="hljs-keyword">Port</span> ( clk : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">STD_LOGIC</span>;<br>           D : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">STD_LOGIC</span>;<br>           Q : <span class="hljs-keyword">out</span>  <span class="hljs-built_in">STD_LOGIC</span>);<br><span class="hljs-keyword">end</span> d_flip_flop;<br><br><span class="hljs-comment">-- 过程风格描述 D 触发器</span><br><span class="hljs-keyword">architecture</span> behavioral <span class="hljs-keyword">of</span> d_flip_flop <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">-- 进程块，响应时钟上升沿</span><br>    <span class="hljs-keyword">process</span>(clk)<br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span><br>            Q &lt;= D; <span class="hljs-comment">-- 在时钟上升沿时，输出 Q 取值为输入 D</span><br>        <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<br><span class="hljs-keyword">end</span> behavioral;<br></code></pre></td></tr></table></figure><p>主要区别：</p><ul><li><p>数据流风格：它只能描述组合逻辑，无法处理时钟事件。因此无法用它实现像 D 触发器这样的时序电路。</p></li><li><p>过程风格：可以处理时钟信号，通过 rising_edge(clk) 检测时钟的上升沿，用于描述寄存器、触发器等时序逻辑。</p></li></ul><p>使用区别：</p><ul><li><p>时钟信号处理：数据流风格只能描述组合逻辑，而过程风格可以处理时钟沿检测，这是它们最显著的区别。时序逻辑依赖于过程风格来触发信号的变化。</p></li><li><p>组合 vs 时序：数据流风格仅适用于组合逻辑，所有信号赋值是同步的，而过程风格可以引入时钟和控制逻辑，实现同步的时序行为。</p></li></ul><p>在哪些地方你可以用到时序语句</p><ul><li>信号赋值语句</li><li>if语句</li><li>case语句</li></ul><h3 id="if语句">if语句</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">then</span><br>  &lt;statements&gt;<br><span class="hljs-keyword">elsif</span> (condition) <span class="hljs-keyword">then</span><br>  &lt;statements&gt;<br><span class="hljs-keyword">else</span><br> &lt;statements&gt;<br> <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br></code></pre></td></tr></table></figure><p>if语句类似条件信号赋值语句，但是更加灵活</p><p>另外，最后的else是用于捕获所有剩余条件的</p><p>举例：</p><p>用if语句写出下面逻辑方程：</p><p>$ F_{OUT}(A,B,C)=AB^{‘}C^{’}+BC $</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">architecture</span> example <span class="hljs-keyword">of</span> my_ex <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  procl: <span class="hljs-keyword">process</span> (A, B, C)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (A = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> B = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> C = <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">then</span><br>      F_OUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">elsif</span> (B = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> C = <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">then</span><br>      F_OUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>      F_OUT &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> procl;<br><span class="hljs-keyword">end</span> example;<br></code></pre></td></tr></table></figure><ul><li>这个大的process块与其它块是并发执行的，但是process中的语句是顺序执行的</li></ul><p>尝试用<strong>过程风格</strong>与<strong>if</strong>语句对下面的复用器描述</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL-Testbench%E4%B8%8E%E4%BB%BF%E7%9C%9F/img_1.png?raw=true" alt></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> mux_8t1 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span> ( DIN: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>       SEL: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>       F  : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> mux_8t1;<br><br><span class="hljs-keyword">architecture</span> arch <span class="hljs-keyword">of</span> mux_8t1 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  my_mux: <span class="hljs-keyword">process</span>(DIN, SEL)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>    (SEL = <span class="hljs-string">&quot;111&quot;</span>) <span class="hljs-keyword">then</span> F &lt;= DIN(<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">elsif</span> (SEL = <span class="hljs-string">&quot;110&quot;</span>) <span class="hljs-keyword">then</span> F &lt;= DIN(<span class="hljs-number">6</span>);<br>    ...<br>    <span class="hljs-keyword">elsif</span> (SEL = <span class="hljs-string">&quot;000&quot;</span>) <span class="hljs-keyword">then</span> F &lt;= DIN(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span>  F &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> my_mux;<br><span class="hljs-keyword">end</span> arch;<br></code></pre></td></tr></table></figure><ul><li>注意要考虑所有的可能</li></ul><h3 id="case语句">case语句</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">case</span> (expression) <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">when</span> choices =&gt;<br>    &lt;statements&gt;<br>  <span class="hljs-keyword">when</span> choices =&gt;<br>    &lt;statements&gt;<br>  <span class="hljs-keyword">when</span> <span class="hljs-keyword">others</span> =&gt;<br>    &lt;statements&gt;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure><p>顺序执行，但只取其中一个值，与C语言一样</p><p>举例：</p><p>$F_{OUT}(A,B,C) = $</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">architecture</span> case_ex <span class="hljs-keyword">of</span> my_ex <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">signal</span> INPUT: <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br><span class="hljs-keyword">begin</span><br>  INPUT &lt;= A &amp; B &amp; C;<br>  proc1: <span class="hljs-keyword">process</span> (INPUT)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span> (INPUT) <span class="hljs-keyword">is</span><br>    <span class="hljs-keyword">when</span> <span class="hljs-string">&quot;100&quot;</span>  =&gt; F_OUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-string">&quot;011&quot;</span>  =&gt; F_OUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-string">&quot;111&quot;</span>  =&gt; F_OUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">others</span> =&gt; F_OUT &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> proc1;<br><span class="hljs-keyword">end</span> case_ex;<br></code></pre></td></tr></table></figure><h1>Simulation &amp; Test Benches</h1><ul><li>在我们前面学习完基础语句，模块编写后，我们需要在出实际电路之前，<br>需要证明电路模块的正确性，这时候就需要利用仿真环境，验证你的电路设计的功能和时序逻辑</li><li>仿真工具通常需要 test bench file 来明确指出如何仿真被测元件</li></ul><h2 id="Test-Bench">Test Bench</h2><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL-Testbench%E4%B8%8E%E4%BB%BF%E7%9C%9F/img_2.png?raw=true" alt></p><ul><li>一个test bench是一个虚拟的电路或者系统，用于创建顶层模块实例（Unit Under Test, UUT），并且为实例产生输入激励</li><li>输出可以被记录与波形可视化，用来验证电路系统的正确性</li><li>testbench本身并不涉及实体的实现与合成</li></ul><h2 id="Example">Example</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">--test bench 的命名，也是通过entity命名--</span><br><span class="hljs-keyword">entity</span> big_xnor_tb <span class="hljs-keyword">is</span><br><span class="hljs-keyword">end</span> big_xnor_tb;<br><span class="hljs-keyword">architecture</span> behavior <span class="hljs-keyword">of</span> big_xnor_tb <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">component</span> big_xnor <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">port</span> (A, B: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>        F   : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">component</span>;<br>  <span class="hljs-keyword">signal</span> A, B, F: <span class="hljs-built_in">std_logic</span>;<br><span class="hljs-keyword">begin</span><br>  uut: big_xnor <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span> (A=&gt;A, B=&gt;B, F=&gt;F);<br>  stim_proc: <span class="hljs-keyword">process</span><br>  <span class="hljs-keyword">begin</span><br>    A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>; B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br>    A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>; B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br>    A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br>    A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br>    <span class="hljs-keyword">wait</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<br><span class="hljs-keyword">end</span> behavior;<br></code></pre></td></tr></table></figure><ul><li>一个test bench 是一个封闭的系统，没有输入输出，正如开头entity没有输入输出一样</li><li>声明UUT component以及中间信号</li><li>赋值输入激励</li></ul><h2 id="时钟信号">时钟信号</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> DFF_tb <span class="hljs-keyword">is</span><br><span class="hljs-keyword">end</span> DFF_tb;<br><span class="hljs-keyword">architecture</span> behavior <span class="hljs-keyword">of</span> DFF_tb <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">component</span> DFF <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">port</span> (D, CLK: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>        Q     : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">component</span>;<br>  <span class="hljs-keyword">signal</span> D, CLK, Q: <span class="hljs-built_in">std_logic</span> := <span class="hljs-string">&#x27;0&#x27;</span>;<br>  <span class="hljs-keyword">constant</span> period: <span class="hljs-built_in">TIME</span> := <span class="hljs-number">10</span> ns;<br><span class="hljs-keyword">begin</span><br>  uut: DFF <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span> (D=&gt;D, CLK=&gt;CLK, Q=&gt;Q);<br>  stim_clk: <span class="hljs-keyword">process</span><br>  <span class="hljs-keyword">begin</span><br>    CLK &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> (period / <span class="hljs-number">2</span>);<br>    CLK &lt;= <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> (period / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<br>  stim_proc: <span class="hljs-keyword">process</span><br>  <span class="hljs-keyword">begin</span><br>  <span class="hljs-comment">--在这里添加输入激励--</span><br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<br><span class="hljs-keyword">end</span> behavior;<br></code></pre></td></tr></table></figure><ul><li>通过操作符“:=”来给某个中间信号或者常量进行初始化赋值</li><li>通过使用constant关键字声明常量</li></ul><h2 id="练习">练习</h2><ul><li>给FA写一个testbench，以下是FA的entity</li><li>需要测试所有情况</li><li>因为模块是组合电路，所以不需要时钟信号</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> FA <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span> (X, Y, CIN: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      S, COUT  : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> FA; <br></code></pre></td></tr></table></figure><ul><li>architecture</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">architecture</span> behavior <span class="hljs-keyword">of</span> full_adder <span class="hljs-keyword">is</span><br>  S &lt;= (X <span class="hljs-keyword">xnor</span> B) <span class="hljs-keyword">xnor</span> CIN:<br>  C_OUT &lt;= (A <span class="hljs-keyword">and</span> B) <span class="hljs-keyword">or</span> (CIN <span class="hljs-keyword">and</span> (A <span class="hljs-keyword">xnor</span> B));<br><span class="hljs-keyword">end</span> behavior;<br></code></pre></td></tr></table></figure><ul><li>testbench</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span>;<br><br><span class="hljs-comment">-- 没有端口的testbench entity</span><br><span class="hljs-keyword">entity</span> tb_full_adder <span class="hljs-keyword">is</span><br><span class="hljs-keyword">end</span> tb_full_adder;<br><br><span class="hljs-keyword">architecture</span> testbench <span class="hljs-keyword">of</span> tb_full_adder <span class="hljs-keyword">is</span><br>    <span class="hljs-comment">-- 组件声明</span><br>    <span class="hljs-keyword">component</span> full_adder<br>        <span class="hljs-keyword">Port</span> ( A    : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">STD_LOGIC</span>;<br>               B    : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">STD_LOGIC</span>;<br>               Cin  : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">STD_LOGIC</span>;<br>               Sum  : <span class="hljs-keyword">out</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>               Cout : <span class="hljs-keyword">out</span> <span class="hljs-built_in">STD_LOGIC</span>);<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">component</span>;<br>    <br>    <span class="hljs-comment">-- 信号声明，用于连接 DUT (Design Under Test)</span><br>    <span class="hljs-keyword">signal</span> A, B, Cin : <span class="hljs-built_in">STD_LOGIC</span>;<br>    <span class="hljs-keyword">signal</span> Sum, Cout : <span class="hljs-built_in">STD_LOGIC</span>;<br><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">-- 实例化 Full Adder</span><br>    uut: full_adder <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span> (<br>        A =&gt; A,<br>        B =&gt; B,<br>        Cin =&gt; Cin,<br>        Sum =&gt; Sum,<br>        Cout =&gt; Cout<br>    );<br><br>    <span class="hljs-comment">-- 测试过程</span><br>    <span class="hljs-keyword">process</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">-- 测试向量 1: A = 0, B = 0, Cin = 0</span><br>        A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br>        <br>        <span class="hljs-comment">-- 测试向量 2: A = 0, B = 0, Cin = 1</span><br>        A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 3: A = 0, B = 1, Cin = 0</span><br>        A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 4: A = 0, B = 1, Cin = 1</span><br>        A &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 5: A = 1, B = 0, Cin = 0</span><br>        A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 6: A = 1, B = 0, Cin = 1</span><br>        A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 7: A = 1, B = 1, Cin = 0</span><br>        A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 测试向量 8: A = 1, B = 1, Cin = 1</span><br>        A &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        B &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        Cin &lt;= <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">for</span> <span class="hljs-number">10</span> ns;<br><br>        <span class="hljs-comment">-- 结束测试</span><br>        <span class="hljs-keyword">wait</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<br><span class="hljs-keyword">end</span> testbench;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数字电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VHDL（二）电路模型</title>
    <link href="/henry.github.io/2024/09/28/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/"/>
    <url>/henry.github.io/2024/09/28/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>学习VHDL的目的</h1><ol><li>学习VHDL用于对数字电路和系统进行建模<ul><li>VHDL对电路描述是十分明确的，可以用来精确描述硬件系统的构成</li><li>VHDL语言提供了任何用来描述数字电路的方式</li></ul></li><li>VHDL可以对数字电路模型和系统进行仿真<ul><li>一些电路模型可以通过VHDL进行仿真和测试<br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/img.png?raw=true" alt="建模方式对比"></li></ul></li></ol><p>也许你会认为使用图像对数字电路进行描述更为方便，但随着电路模块与电线增多，图像将会变得十分复杂</p><p>更为明智的方式，是通过VHDL语言对电路进行描述（建模model it），然后将具体连接细节留给合成工具（合成器synthesiser）</p><h2 id="数字系统设计流程">数字系统设计流程</h2><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/img_1.png?raw=true" alt="数字系统设计流程"></p><ul><li>电路系统设计者应该重点关心：最终的逻辑电路应该做什么，即：通过对数字系统的抽象化，提炼功能与接口。可以使用VHDL建模</li><li>合成器：将VHDL具象化作最终的实际电路</li><li>最终通过合成器得到的电路结果整合成目标设备</li></ul><p>而我们这里重点是学习：如何准确恰当地对数字电路系统建模</p><h1>VHDL的 Gorden Rule</h1><ol><li>时刻记住VHDL是一种硬件设计语言<ul><li>当我们使用VHDL时，我们不是在编程，而是在设计硬件</li></ul></li><li>熟悉基本的数字电路系统的结构，例如逻辑门等</li></ol><h1>Component 组件</h1><p>试着描述这个电路系统</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B/img_2.png?raw=true" alt></p><p>现在我们试着使用component进行描述</p><p>我们按步骤设计：</p><ol><li>设计顶层实体，即对整体系统的输入输出进行描述</li><li>声明底层模块单元</li><li>声明中间信号</li><li>创建companies和map实例</li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br><br><span class="hljs-comment">--entity--</span><br><span class="hljs-comment">--1.设计顶层实体，即对整体系统的输入输出进行描述--</span><br><span class="hljs-keyword">entity</span> my_compare <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>(A_IN   : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>     B_IN   : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>     EQ_OUT : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> my_compare;<br><br><span class="hljs-comment">--architecture--</span><br><span class="hljs-keyword">architecture</span> structural <span class="hljs-keyword">of</span> my_compare <span class="hljs-keyword">is</span><br><span class="hljs-comment">--2. 声明底层模块单元 component --</span><br>   <span class="hljs-keyword">component</span> big_xnor <span class="hljs-keyword">is</span><br>   <span class="hljs-keyword">port</span>(A, B : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>        F    : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">component</span>;<br>   <br>   <span class="hljs-keyword">component</span> big_and3 <span class="hljs-keyword">is</span><br>   <span class="hljs-keyword">port</span>(A, B, C : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>        F       : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">component</span>;<br>   <br>   <span class="hljs-comment">-- 3.声明中间信号 --</span><br>   <span class="hljs-comment">-- internal signal declarations</span><br>   <span class="hljs-keyword">signal</span> p1_out, p2_out, p3_out: <span class="hljs-built_in">std_logic</span>;<br><span class="hljs-keyword">begin</span><br>   x1: big_xnor <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(A =&gt; A_IN(<span class="hljs-number">2</span>), B =&gt; B_IN(<span class="hljs-number">2</span>), F =&gt; p1_out);<br>   x2: big_xnor <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(A =&gt; A_IN(<span class="hljs-number">1</span>), B =&gt; B_IN(<span class="hljs-number">1</span>), F =&gt; p2_out);<br>   x3: big_xnor <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(A =&gt; A_IN(<span class="hljs-number">0</span>), B =&gt; B_IN(<span class="hljs-number">0</span>), F =&gt; p3_out);<br>   a1: big_and3 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(A =&gt; p1_out, B =&gt; p2_out,<br>                         C =&gt; p3_out, F =&gt; EQ_OUT);<br><span class="hljs-keyword">end</span> structural;<br></code></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li><p>对于每个component，其输入输出的名称只是形参</p></li><li><p>变量名称应该能够体现模型电路元件之间的连接、映射关系，这样有利于理解电路描述</p></li><li><p>component通过mapping将信号输入输出</p></li><li><p>实践过程中发现，不能将一个表达式当作参数置入，这和一般的编程方式不同，一般会在仿真阶段出现问题，会出现无法出现变量和波形的情况</p><ul><li>例如：port map(A=&gt;(NOT A_IN)类似这样的输入是不允许的，因为NOT A_IN并不是一个全局的静态变量</li></ul></li></ol><h2 id="Mapping">Mapping</h2><p>映射指的是：将前部模块的输出信号作为输入信号连接到底层模块</p><h3 id="显式映射和隐式映射">显式映射和隐式映射</h3><p><strong>显式映射</strong></p><ul><li>底层接口中的每个信号都被列出，并且与高层信号通过 &quot; &lt;= &quot; 操作符进行连接<ul><li>优点：明确、完整的描述电路系统</li><li>缺点：这样会增添代码量</li></ul></li></ul><p><strong>隐式映射</strong></p><ul><li>类似于C语言中调用函数时，需要你写入参数</li><li>通常在高级设计中出现</li><li>映射遵循entity输入输出的顺序<ul><li>优点：占用代码空间较少</li><li>缺点：需要将信号按正确顺序放置（个人感觉不算什么缺点）</li></ul></li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">-- implicit mapping (A =&gt;, B =&gt;, F =&gt;)</span><br>x3: big_xnor <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(A_IN(<span class="hljs-number">0</span>), B_IN(<span class="hljs-number">0</span>), p1_out);<br></code></pre></td></tr></table></figure><h1>总结</h1><ul><li>VHDL是一种用于描述硬件-数字电路和系统的特定语言<ul><li>尽管语法相似，但与 像C或Java这样的编程语言非常不同</li></ul></li><li>VHDL必须被合成并实现适当的设备来创建实际的系统</li><li>VHDL遵循黑盒设计，将一个module分为：<ul><li>entity 实体:输入/输出接口</li><li>architecture 架构:内部工作/结构</li></ul></li><li>IEEE定义了逻辑设计的通用库，数字信号的基本类型是：std_logic</li><li>总线信号用 std_logic_vector表示</li><li>VHDL对大小写和空格不敏感，并且对括号不敏感</li><li>结构建模支持分层和模块化设计</li><li>设计人员可以使用库中的开发与测试完善的blocks来构建一个可靠的系统</li><li>组件是结构建模的核心，步骤包括:声明、实例化和映射。</li><li>映射包括显式映射和隐式映射</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数字电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VHDL（一）基础学习</title>
    <link href="/henry.github.io/2024/09/27/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/henry.github.io/2024/09/27/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>关于VHDL</h1><ul><li>V = Very High-Speed Integrated Circuit (VHSIC)</li><li>HDL = Hardware Descriptive Language</li><li>VHDL是一种计算机语言，具有相应的语法和使用规则</li><li>VHDL主要用于描述硬件</li><li>相比于其它计算机语言，VHDL并不是顺序运行的</li><li>VHDL是一种并行语言，因为他是用于描述并行执行的硬件的语言</li><li>不要用C语言一类的顺序执行的编程语言的思路，否则会有很多错误</li></ul><h2 id="VHDL特性与基本规则">VHDL特性与基本规则</h2><ol><li>VHDL不区分大小写</li></ol><ul><li>可以根据自己的情况写大小写</li><li>如下语句是合法的：<ul><li>Dout &lt;= A and B; is the same as doUt &lt;= a AnD b;</li></ul></li></ul><ol start="2"><li>VHDL不对空格敏感</li></ol><ul><li><p>应该合理使用空格和制表符</p></li><li><p>如下语句是合法的：</p><ul><li>nQ &lt;= In_a or In_b; is the same as</li><li>nQ   &lt;= in_a OR        in_b;</li></ul></li></ul><ol start="3"><li>VHDL的注释使用 ‘-’ 符号，另外，VHDL不存在块注释</li></ol><ul><li>注释示例： – This is a comments.</li></ul><ol start="4"><li>VHDL同样存在操作符优先的规则,尽量使用括号保证运算与阅读合理</li></ol><h1>语法</h1><h2 id="标识符-Identifiers">标识符 Identifiers</h2><ul><li>标识符指的是VHDL中item的名称，类似于C语言中的变量、函数等</li><li>VHDL中的标识符包括：signal names, port names, variable names, etc.<ul><li>必须以字母开头</li><li>不能以下划线结尾</li><li>不能有两个相连的下划线</li></ul></li></ul><h2 id="保留字">保留字</h2><p>VHDL中具有特殊含义的字符，不可用作标识符</p><ul><li>library</li><li>all</li><li>entity</li><li>architecture</li><li>is</li><li>port</li><li>in</li><li>out</li><li>begin</li><li>and</li><li>not</li><li>of</li><li>end</li><li>…</li></ul><h3 id="逻辑运算符保留字符">逻辑运算符保留字符</h3><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/LogicOperator.png?raw=true" alt="LogicOperator"></p><h2 id="IEEE-标准库">IEEE 标准库</h2><ul><li>数据类型std_logic, std_logic_vector 由IEEE标准化，用于表示数字信号</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><h2 id="Entity">Entity</h2><ul><li>entity声明描述了电路的接口或外部表示</li><li>VHDL中的entity用于将电路的部分功能抽象化描述<ul><li>实体简单地列出了底层电路的输入输出情况</li><li>相当于把功能的细节和实现封装到黑盒中，我们只关心黑盒的输入输出</li></ul></li></ul><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_2.png?raw=true" alt></p><ul><li>示例</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">-- interface description of killer_ckt</span><br><span class="hljs-keyword">entity</span> killer_ckt <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( life_in1      : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      life_in2      : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      ctrl_a, ctrl_b: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      kill_a        : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>;<br>      kill_b, kill_c: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> killer_ckt;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/killer_ckt.png?raw=true" alt></p><ul><li>需要写明entity名称，port端口，每个port名称以及数据类型</li><li>port可以并排声明，用逗号隔开</li><li>在VHDL中，注释使用 ‘–’</li></ul><h3 id="重点注意">重点注意</h3><ol><li>‘is’ 后面没有冒号</li><li>每个端口定义后面需要加分号</li><li>最后一个端口后面不加分号，在port定义外加</li><li>entity定义完成后的 ‘end’ 后面要加分号</li><li>VHDL中的赋值操作符是“&lt;=”</li><li>VHDL中的所有语句都是并行执行的</li></ol><h2 id="std-logic-std-logic-vector">std_logic &amp; std_logic_vector</h2><ul><li><p>std_logic 定义的是长度为 1 的逻辑，类似于bit，但bit只有 0，1两种状态，但std_logic有9种状态</p><ul><li>9种状态：<ul><li>‘U’ – 初始值</li><li>‘X’ – 不定</li><li>‘0’ – 0</li><li>‘1’ – 1</li><li>‘Z’ – 高阻</li><li>‘W’ – 弱信号不定</li><li>‘L’ – 弱信号0</li><li>‘H’ – 弱信号1</li><li>‘-’ – 不可能的情况</li></ul></li></ul></li><li><p>std_logic_vector 是标准逻辑矢量，或者又说为bus signal，定义的是长度大于1的变量</p><ul><li>需要确定赋值方向 左侧到右侧(n downto 0) or 右侧到左侧(0 downto n)<br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_3.png?raw=true" alt></li></ul></li><li><p>练习</p></li></ul><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img.png?raw=true" alt></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> alu4 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( A, B  : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      F     : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      CIN   : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      <br>      OUTPUT: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      COUT  : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> alu4;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_4.png?raw=true" alt></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">entity</span> mux4 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( a_data:     <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      b_data:     <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      c_data:     <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      d_data:     <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>      sell, sel10:<span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      data_out:   <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>));<br><span class="hljs-keyword">end</span> mux4;<br></code></pre></td></tr></table></figure><h2 id="Architecture">Architecture</h2><ul><li>architecture描述了对应实体的内部实现</li><li>描述architecture相对entity较为复杂</li><li>如何使用VHDL对电路描述，这很大程度上决定了电路系统的最终效果和速度，VHDL描述的是电路在实际的硅器件的具体实现</li></ul><h2 id="Concurrent-Statements-并发语句">Concurrent Statements 并发语句</h2><ul><li>并行性是硬件世界中常见的概念</li><li>相比于一般的计算机语言是顺序执行的方式，VHDL是通过并发方式执行的</li></ul><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_6.png?raw=true" alt></p><p>多个输入端同时改变电平时，将会同时被作输入处理，与你在VHDL代码中写下他们的顺序无关</p><h2 id="Intermediate-Signals-中间信号">Intermediate Signals 中间信号</h2><ul><li>当电路比较复杂时，我们会特意声明中间信号来作为中介，获得上一部分元件的结果，作为下一部分的输入</li><li>声明时需要声明类型，但不需要声明输入或输出</li></ul><h3 id="中间信号的优点">中间信号的优点</h3><ul><li>大多数字电路是比较复杂的，利用好中间信号可以让你的描述语言更加流畅</li><li>中间信号就像电路内部的导线一样，帮助你把电路的不同部分连接在一起</li></ul><h2 id="Conditional-Signal-Assignment-条件信号赋值">Conditional Signal Assignment 条件信号赋值</h2><ul><li>基本语法：</li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs VHDL">&lt;target&gt; &lt;= &lt;expression&gt; <span class="hljs-keyword">when</span> &lt;condition&gt; <span class="hljs-keyword">else</span><br>            &lt;expression&gt; <span class="hljs-keyword">when</span> &lt;condition&gt; <span class="hljs-keyword">else</span><br>            &lt;expression&gt;;<br></code></pre></td></tr></table></figure><ul><li><p>一个目标与多个表达式关联，每个表达式都与一个条件相关联</p></li><li><p>直到一个条件为真，再将表达式赋值给目标</p></li><li><p>示例: F3 = L’M’N + LM</p></li></ul><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br><span class="hljs-keyword">entity</span> my_ckt_f3 <span class="hljs-keyword">is</span><br>...<br><span class="hljs-keyword">END</span>;<br><br><span class="hljs-keyword">architecture</span> f3_3 <span class="hljs-keyword">of</span> my_ckt_f3 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  F3 &lt;= <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">when</span> (L = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> M = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> N = <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">else</span><br>        <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">when</span> (L = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> M = <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">else</span><br>        <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">end</span> f3_3;<br></code></pre></td></tr></table></figure><ul><li>最后需要将没有考虑到的情况的输出考虑进去</li></ul><h2 id="Relational-Operators-关系运算符">Relational Operators 关系运算符</h2><ul><li>’ = ’ 可以用来判断等于</li><li>’ /= ’ 用来判断不等于</li><li>VHDL实际上有6种关系运算符，后面再进行讨论</li></ul><h1>VHDL练习</h1><ol><li>2-input NOR Gate</li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">--- file: nor2.vhd ---</span><br><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br><span class="hljs-keyword">entity</span> nor2 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( A, B: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      F   : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span>;<br><span class="hljs-comment">-- the gate level architecture for nor2</span><br><span class="hljs-keyword">architecture</span> myarch <span class="hljs-keyword">of</span> nor2<br><span class="hljs-keyword">begin</span><br>  F &lt;= <span class="hljs-keyword">not</span>(A <span class="hljs-keyword">or</span> B);<br><span class="hljs-keyword">end</span> myarch;<br></code></pre></td></tr></table></figure><ol start="2"><li>2-input NAND Gate<br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_5.png?raw=true" alt></li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE;<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br><span class="hljs-keyword">entity</span> nand2 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( A, B: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      F:    <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> nand2;<br><br><span class="hljs-keyword">architecture</span> nand2_arch <span class="hljs-keyword">of</span> nand2 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br>  F &lt;= <span class="hljs-keyword">not</span>(A <span class="hljs-keyword">and</span> B);<br><span class="hljs-keyword">end</span> nand2_arch;<br></code></pre></td></tr></table></figure><ol start="3"><li>3-input NAND Gate<br><img src="https://github.com/jhr419/henry.github.io/blob/master/img/VHDL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/img_1.png?raw=true" alt></li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">library</span> IEEE<br><span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br><span class="hljs-comment">-- three-input NAND</span><br><span class="hljs-keyword">entity</span> my_nand3 <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>( A, B, C: <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>      F      : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<br><span class="hljs-keyword">end</span> my_nand3;<br><br>architechture my_nand3_arch <span class="hljs-keyword">of</span> my_nand3 <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">signal</span> D: <span class="hljs-built_in">std_logic</span>;<br><span class="hljs-keyword">begin</span><br>  D &lt;= A <span class="hljs-keyword">and</span> B <span class="hljs-keyword">and</span> C;<br><span class="hljs-keyword">end</span> my_nand3_arch;<br></code></pre></td></tr></table></figure><h1>VHDL 代码模块通用模板</h1><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">---- Descriptions about -------- your VHDL code     ---</span><br><span class="hljs-keyword">library</span> IEEE;<br> <span class="hljs-keyword">use</span> IEEE.std_logic_1164.<span class="hljs-keyword">all</span>;<br> <span class="hljs-comment">-- ENTITY -</span><br><span class="hljs-keyword">entity</span> module_name <span class="hljs-keyword">is</span><br> <span class="hljs-keyword">port</span>( in1: <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br> ...<br> out1: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>;<br> ...); <br> <span class="hljs-keyword">end</span> module_name;<br> <span class="hljs-comment">-- ARCHITECTURE -</span><br><span class="hljs-keyword">architecture</span> module_arch <span class="hljs-keyword">of</span> module_name <span class="hljs-keyword">is</span><br> ... <span class="hljs-comment">-- DECLARATIONS</span><br> <span class="hljs-keyword">begin</span><br> ... <span class="hljs-comment">-- STATEMENTS</span><br> <span class="hljs-keyword">end</span> module_arch;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数字电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级网络编程-第一周-线程</title>
    <link href="/henry.github.io/2024/09/10/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E5%91%A8-%E7%BA%BF%E7%A8%8B/"/>
    <url>/henry.github.io/2024/09/10/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E5%91%A8-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>进程与线程</h1><h2 id="进程">进程</h2><p>一个进程就是内存中运行的一个应用程序，比如在Windows系统中，一个运行的.exe就是一个进程。每个进程都有自己独立的内存空间，一个进程可以有多个线程。</p><h2 id="线程">线程</h2><p>一个线程就是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="区别与联系">区别与联系</h3><ol><li>A process runs independently and isolated from other processes.</li><li>Aprocess cannot directly access shared data in other processes.x</li></ol><h1>并存编程相关概念</h1><ol><li>Atomicity</li><li>Visibility</li><li>Order of execution</li><li>Critical code</li></ol><h1>Thread 类</h1><p>· Thread类会执行编程者线程中的内容逻辑</p><p>· 线程的内容逻辑存在于 <strong>run()</strong> 方法</p><p>· Thread类管理所有运行中的线程</p><h2 id="创建一个线程">创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p><ol><li>通过实现 Runnable 接口，并在类中创建Thread对象</li><li>通过继承 Thread 类本身，需要实现超类中的待实现的方法run()</li><li>通过 Callable 和 Future 创建线程。</li></ol><h3 id="方式一：实现Runnable-接口">方式一：实现Runnable 接口</h3><p>声明一个Runnable的类</p><p>实现run方法</p><p>新建Thread示例，并将类放入实例</p><ul><li>Runnable接口要求类必须实现run()方法，否则会compile error</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//stuff here</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// This approach uses a class that implements the Runnable interface</span><br><span class="hljs-comment">// this is the recommended way.</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>或者可以更简单的代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>())<br>&#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//stuff here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>倘若要多次使用相同的runnable：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">MyFirstRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFirstRunnable</span>();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">25</span>; i++)<br>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>currentThread()</li></ul><p>这个方法可以返回当前执行的线程的reference</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>    &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：继承Thread类">方式二：继承Thread类</h3><p>需要override run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//stuff here</span><br>&#125;<br><br><span class="hljs-comment">// We&#x27;ll now create a thread </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// This approach uses a class the extends Thread</span><br><span class="hljs-type">MyFirstThreadExtend</span> <span class="hljs-variable">myFirstThreadExtend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFirstThreadExtend</span>();<br>myFirstThreadExtend.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式三：通过-Callable-和-Future-创建线程（略）">方式三：通过 Callable 和 Future 创建线程（略）</h3><p><strong>思考：哪种方式更好呢？</strong></p><p>通过继承Thread类的方式，可以完成多线程的建立。</p><p>但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java是单继承。</p><p>可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？</p><p>只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。</p><p>这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。</p><p><strong>所以，通常创建线程都用第二种方式。</strong></p><p>因为实现Runnable接口可以避免单继承的局限性。</p><p>将多线程要运行的代码的位置单独定义到接口中，这为其他类进行功能扩展提供了前提。</p><p>因为Thread类在描述线程时，其内部定义的run方法，也来自于Runnable接口。</p><p>实现Runnable接口可以避免单继承的局限性，继承Thread是可以对Thread类中的方法进行子类复写的。</p><p>如果不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。</p><p>因为Runnable接口将线程要执行的任务封装成了对象。</p><h1>线程的常用方法</h1><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>public void start()</td><td>使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td></tr><tr><td>public void run()</td><td>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td>static void sleep(long millis)</td><td>Can make a thread sleep for a certain number of milliseconds</td></tr><tr><td>public final void setName(String name)</td><td>改变线程名称，使之与参数 name 相同。</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改线程的优先级。</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将该线程标记为守护线程或用户线程。</td></tr><tr><td>public final void join(long millisec)</td><td>等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td>public void interrupt()</td><td>中断线程。</td></tr><tr><td>public final boolean isAlive()</td><td>测试线程是否处于活动状态。</td></tr></tbody></table><h2 id="static-void-sleep-long-millis">static void sleep(long millis)</h2><p>可以使得进程休眠固定时间长度，单位：毫秒</p><p>不能控制其它线程休眠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(InterruptedException e)<br>    &#123;<br>        <span class="hljs-comment">//一些线程操作可能抛出异常</span><br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="static-voidyield">static voidyield()</h2><p>When a thread executes a thread yield,</p><p>– the executing thread is suspended and</p><p>– the CPU is given to some other runnable thread</p><p>• This thread will wait until the CPU becomes available again • Technically, in process scheduler’s terminology,</p><p>– the executing thread is returned to the ready queue of the processor and– waits for its next turn</p><p>当一个线程执行yield()时，正在执行的线程会被挂起，CPU会将资源分配给其它可执行线程，直到CPU资源对该线程再次可用</p><p>在进程调度程序的术语中，正在执行的线程会转变到处理器的准备队列中，并且等待下一次变换状态</p><h1>InterruptedException</h1><p>这个exception 会在当线程处于睡眠状态时被中断而抛出，可以很好的处理中断</p><h2 id="Interrupt-flag">Interrupt flag</h2><p>每个线程对象都包含一个中断标志变量，</p><p>其它线程可以改变这个标志为true来中断该线程</p><p>执行t1.interrupt()，那么t1就是我们要中断的线程</p><p>方法应该检查这个标志：</p><p>如果为true：则立刻结束当前执行的方法；</p><p>如果为false：照常进行该方法</p><p>当实现实现方法时，将对中断标志的检查纳入你的方法中是一个好习惯。</p><p>这意味着在编写多线程代码时，你应该在方法中定期检查线程的中断标志（interrupt flag）。如果标志被设置为 true，则方法应立即结束（返回）；如果标志为 false，则继续正常执行。</p><p>这样做可以使线程在需要中断时及时响应，提高程序的可控性和稳定性。</p><h2 id="线程如何响应中断">线程如何响应中断</h2><p>如果一个线程处于sleeping或者waiting状态下（即sleep(), wait()被调用），此时使用interrupt()，会退出sleeping或者waiting的状态，通过设置flag为false，并抛出InterruptedException</p><p>如果一个线程不处于sleeping或者waiting状态，当调用interrupt()，会照常执行原本的内容，不会中断线程，只会将interrupt flag 设置为true</p><h2 id="何时中断线程">何时中断线程</h2><ol><li>当线程处于堵塞状态（blocked），堵塞即线程此时无法做任何事情</li><li>当一个线程处于sleep状态，但我们想要等待它完成，那么我们就可以中断它然后继续我们的任务</li></ol><h2 id="线程堵塞的原因">线程堵塞的原因</h2><ol><li>线程可能正等待monitor lock（监视器锁）</li><li>线程可能被wait()挂起了，并且会变成runnable状态</li></ol><p>sleep()和wait()/notify()可能是线程被阻塞的最主要的情况</p><p>调用interrupt()可以强制使得线程脱离堵塞</p><h2 id="Thread线程状态">Thread线程状态</h2><p>在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。<br>一旦run()方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行run()方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；</li><li>Terminated：线程已终止，因为run()方法执行完毕。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">          ┌─────────────┐<br>          │     New     │<br>          └─────────────┘<br>                 │<br>                 ▼<br>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>  ┌─────────────┐ ┌─────────────┐<br>│ │  Runnable   │ │   <span class="hljs-keyword">Blocked </span>  │ │<br>  └─────────────┘ └─────────────┘<br>│ ┌─────────────┐ ┌─────────────┐ │<br>  │   <span class="hljs-keyword">Waiting </span>  │ │Timed <span class="hljs-keyword">Waiting│</span><br><span class="hljs-keyword"></span>│ └─────────────┘ └─────────────┘ │<br>  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─<br>                 │<br>                 ▼<br>          ┌─────────────┐<br>          │ Terminated  │<br>          └─────────────┘<br></code></pre></td></tr></table></figure><p>细节可见：<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html">https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html</a></p><h1>线程间配合 Coordinating between Threads</h1><h2 id="join">join()</h2><p>让主线程等待，直到其它线程不再活动为止</p><p>join()方法可以等待其它线程停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">//Wait for thread2 to die</span><br>    thread2.join();<br>&#125; <br><span class="hljs-keyword">catch</span>(InterruptedException e)<br>&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>将会让当前进程等待线程2停止</p><h1>Interrupt</h1><h2 id="什么是interrupt">什么是interrupt</h2><p>如果线程需要执行一个长时间任务，就可能中断线程。中断线程就是其它线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立即结束运行</p><h1>总结本节用到的方法</h1><ul><li><p>Thread.sleep(1000);</p><ul><li>Pauses current thread from executing for 1000 milliseconds</li></ul></li><li><p>myThread.join();</p><ul><li><p>Pauses current thread until myThread has finished executing,</p><p>i.e., myThread’s run() method has finished</p></li></ul><p>执行thread1.run()后，主线程会等待thread1子线程执行完任务，再回到主线程继续执行后续主线程任务。<br>本质上就是在主线程中开始等待这个子线程结束任务</p></li><li><p>myThread.interrupt();</p><ul><li>Send an interrupt signal to myThread</li><li>This will set myThread’s interrupt flag to true</li></ul></li></ul><p>start() 和 run() 的区别</p><p>start是创建新的进程，并且运行run方法中的代码</p><p>run是不会创建新的进程，run方法内部的代码将在当前线程上运行。</p><p>如果你想要运行需要消耗大量时间的任务，你最好使用start方法，</p><p>否则在你调用run方法的时候，你的主线程将会被卡住，</p><p>这是因为，调用run方法，其实是在调用一个普通的Java方法，是顺序执行的，</p><p>必须等待run方法体里的内容执行完毕后才能执行别的代码块，</p><p>而调用start()方法的话，则是启动一个新线程，等待JVM来调用run()方法体里的内容，</p><p>所以可能先执行别的代码块而后执行run()方法体。</p><p>另外一个区别在于，一但一个线程被启动，你不能重复调用该thread对象的start方法，</p><p>调用已经启动线程的start方法将会报IllegalStateException异常，而你却可以重复调用run方法。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>高级网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>高级网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩散模型—理论与拓展</title>
    <link href="/henry.github.io/2024/09/10/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E2%80%94%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8B%93%E5%B1%95/"/>
    <url>/henry.github.io/2024/09/10/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E2%80%94%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于“!1”你用对了吗？——关于不同语言下的数据表示及其反补码</title>
    <link href="/henry.github.io/2024/07/23/%E5%85%B3%E4%BA%8E%E2%80%98-1%E2%80%99%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97%EF%BC%9F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%A1%A5%E7%A0%81/"/>
    <url>/henry.github.io/2024/07/23/%E5%85%B3%E4%BA%8E%E2%80%98-1%E2%80%99%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97%EF%BC%9F%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%A1%A5%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>摘要：笔者写的代码不多，能力有限，文章主要是将自己在实践过程中遇到的问题记录汇总，同时拓展学习一下知识，文章内容如有纰漏，或者各位大佬有更高的见解，欢迎联系笔者一起交流学习，联系方式在我的主页。</strong></p><hr><h1>背景</h1><p>我们先来看这样一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">global</span> cnt<br>cnt = self.cnt<br>UnitENU = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>])<br>...<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(PosENU[<span class="hljs-number">0</span>] - UnitENU[<span class="hljs-number">0</span>]*(cnt+<span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0.2</span> :<br>&#123;<br>    ...<br>    target_pos = np.array([UnitENU[<span class="hljs-number">0</span>]*(cnt+<span class="hljs-number">1</span>), UnitENU[<span class="hljs-number">1</span>]*(cnt%<span class="hljs-number">2</span>), UnitENU[<span class="hljs-number">2</span>]])<br>    ...<br>&#125;<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">abs</span>( PosENU[<span class="hljs-number">0</span>] - UnitENU[<span class="hljs-number">0</span>]*(cnt+<span class="hljs-number">1</span>) ) &lt; <span class="hljs-number">0.2</span> :<br>    <span class="hljs-keyword">if</span>  <span class="hljs-built_in">abs</span>(PosENU[<span class="hljs-number">1</span>] - UnitENU[<span class="hljs-number">1</span>]*((cnt+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>)) &gt;= <span class="hljs-number">0.2</span> :<br>        target_pos = np.array([UnitENU[<span class="hljs-number">0</span>]*(cnt+<span class="hljs-number">1</span>), UnitENU[<span class="hljs-number">1</span>]*((cnt+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>)， UnitENU[<span class="hljs-number">2</span>]])<br>        <br>    <span class="hljs-keyword">if</span> ~(cnt%<span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>( PosENU[<span class="hljs-number">1</span>] - UnitENU[<span class="hljs-number">1</span>]*((cnt+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>) ) &lt; <span class="hljs-number">0.2</span> :<br>    &#123;<br>        ...<br>        cnt+=<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">elif</span> cnt%<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(PosENU[<span class="hljs-number">1</span>] - <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0.2</span>:<br>    &#123;<br>        ...<br>        cnt+=<span class="hljs-number">1</span><br>    &#125;<br>...<br><span class="hljs-comment">#将target_pos转换成速度指令通过ros节点pub</span><br>...<br></code></pre></td></tr></table></figure><p>背景是一个无人机搜索任务，搜索路径是一个简单的S环路，这段代码是其中一段让无人机在不同路段区间内执行向左或向右平飞，通过计数器<strong>cnt</strong>判断当前无人机处于哪一部分路段。</p><h2 id="问题描述">问题描述</h2><p>这里 UnitENU[1] 是向左飞行的最大距离，是一个常数，也就是说当无人机在左侧最远点±0.2米的范围内，并且当<strong>cnt</strong>为偶数时才会进入第一个判断块。</p><p>但是实际上机测试发现无人机只会进入第一个判断中，当到达左侧最远点会进入语句块，这没问题，此时目标会更新在正前方一个单位长度的位置，当无人机向前飞行到达目标范围内,按理不应该更新计数器，同时开始向右飞到右侧最远点，当飞到最右侧才会更新计数器。</p><p>但是每次当我在左侧向前飞行一个单位长度后，都会直接更新计数器，导致会跳过向右平飞的路径节点，直接从左边斜向前飞向下一个节点。</p><h1>解决方案</h1><p>之后将判断语句改为如下，问题解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python">...<br>    <span class="hljs-keyword">if</span> cnt%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>( PosENU[<span class="hljs-number">1</span>] - UnitENU[<span class="hljs-number">1</span>]*((cnt+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>) ) &lt; <span class="hljs-number">0.2</span> :<br>    &#123;<br>        ...<br>        cnt+=<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">elif</span> cnt%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(PosENU[<span class="hljs-number">1</span>] - <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0.2</span>:<br>    &#123;<br>        ...<br>        cnt+=<span class="hljs-number">1</span><br>    &#125;<br>...<br></code></pre></td></tr></table></figure><h1>问题分析</h1><p>由于笔者之前基本都是写C语言程序，因此很长时间都一直用C语言的思维在写python的代码（还被师兄吐槽你这代码风格太C了），因此在debug时，一直认为这里对计数器的处理不存在问题。</p><p>通过在终端打印变量测试，发现每次<strong>cnt</strong>的更新都是通过第一个判断块执行，似乎说明 ~(cnt%2) 根本不起作用，值永远为<strong>true</strong>，或者说，是一个非0数，所以每次只要在左侧的最新目标点位置范围内就会触发计数器更新。</p><p>但是在修改代码后，可以看到，cnt%2 的值仍然可以在 0 ，1之间改变。</p><p>难道python中表达式 ~1 的值不是 0？</p><h2 id="验证猜想">验证猜想</h2><p>写下如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">print</span>(~<span class="hljs-number">1</span>)<br><br>输出：-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>诶？ ~1的结果不应该是0吗，为什么打印输出 -2 呢？<br>要不我们试着打印出这个过程中两个数的二进制数来看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(-<span class="hljs-number">2</span>))<br><br>输出： <br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> 00000001<br><span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111110</span><br></code></pre></td></tr></table></figure><p>答案一目了然了不是吗？</p><p>在python中，整数以32位二进制数存储，当对一个整数使用‘~‘操作，即按位取反操作符，则32位全部取反，而取反的结果0xFFFFFFFE正是-2的二进制补码，所以打印出来的结果就是-2</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第四周-Garbage-Collection</title>
    <link href="/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/"/>
    <url>/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/</url>
    
    <content type="html"><![CDATA[<h1></h1><p><a href="http://t.csdnimg.cn/BFuJ3">http://t.csdnimg.cn/BFuJ3</a></p><h1>Heap 和 Stack</h1><h2 id="当运行Java程序时">当运行Java程序时</h2><p>JVM为程序提供内存，来自所使用的OS</p><h2 id="Java两种主要内存域">Java两种主要内存域</h2><p>Heap：对象实例，数组在此</p><p>Stack：局部变量，方法在此，当被调用时，才会处于存活状态</p><h1>局部变量&amp;实例变量</h1><p>我们主要关注的变量类型：</p><h2 id="局部变量（也叫栈变量）Local-also-known-as-stack-variables：">局部变量（也叫栈变量）Local(also known as stack) variables：</h2><p>在方法中和方法参数中声明的变量</p><p>它们是临时变量，只有当它们所属的方法处于栈上时，它们才是存活状态</p><h2 id="实例变量-Instance-veriables：">实例变量 Instance veriables：</h2><p>在类中，方法之外的变量</p><p>在属于它们的对象中存活（）</p><p>问：instance 变量和 class变量区别？</p><p>答：类变量是静态变量，属于类本身的，extend了该类的子类和该类的对象实例都可以使用</p><p>实例变量是属于对象的，每个对象中都有一个实例变量的副本</p><h1>方法与栈</h1><p>当方法被调用，它会在栈顶，保留直到使用完成</p><h2 id="栈帧">栈帧</h2><p>实际被推入栈中的内容</p><p>包含方法的状态（哪一行代码正在执行和局部代码的值）</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/pic1.png?raw=true" alt="pic"></p><p>栈帧是指函数在被调用时，所拥有的一块独立的用于存放函数所使用的状态和变量的栈空间。每个函数都对应有一个栈帧。同一个函数多次进入，每次可能会分配到不同的栈帧。整个栈的内容在同一个时刻可以看作是由许多栈帧依序“堆叠”组成的。</p><p><a href="https://ctfbook.ph0en1x.com/reverse/zhan-3001-zhan-zheng-yu-han-shu-diao-yong">https://ctfbook.ph0en1x.com/reverse/zhan-3001-zhan-zheng-yu-han-shu-diao-yong</a></p><h1>对象引用&amp;变量存储位置</h1><h2 id="Object-reference-aka-non-primitive-variables-对象引用变量：">Object reference (aka non-primitive) variables 对象引用变量：</h2><p>保存一个对象的引用，而不是实际的对象</p><p>一个是对象的引用的局部变量存在于栈中，而对象本身仍然在堆中</p><h2 id="变量存储位置：">变量存储位置：</h2><p>Instance variables：在堆中</p><p>Local variables：在栈中</p><h1>Superclasses, Inheritance &amp; Constructors</h1><h2 id="关系：">关系：</h2><ol><li>每个对象都包含它们自己声明的实例变量和从它们超类中的所有内容</li><li>当对象被创建，对象将会有代表每个超类的“层”</li><li>Java中所有类都是继承了Object，它是万类之母</li></ol><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/pic2.png?raw=true" alt="pic"></p><h2 id="构造器链式">构造器链式</h2><ol><li>当创建一个新的对象，在它的继承树中的所有构造器都会执行</li><li>当执行new时，会触发构造函数的链式反应</li><li>一个类只有当超类部分全部形成后才算完全形成</li></ol><h1>执行构造器</h1><p>子类的所有构造器的第一行，都有一句隐身的super()</p><ol><li><p>当父类存在无参构造器，或者不存在有参构造器（JVM会默认给出无参构造器）：</p><p>子类会自动调用父类的无参构造器，即默认构造器</p></li><li><p>当父类构造器有参，且没有给出无参构造器</p><p>由于子类构造器会默认执行父类无参构造器，而父类不存在无参构造器，此时编译不能通过</p></li></ol><p><a href="http://t.csdnimg.cn/ywJEi">http://t.csdnimg.cn/ywJEi</a></p><h2 id="编译器和生成构造器">编译器和生成构造器</h2><ol><li>若类中没有提供构造器，编译器会默认添加一个诸如下方的构造器：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">public ClassName() &#123; <span class="hljs-built_in">super</span>(); &#125;<br></code></pre></td></tr></table></figure><p>！！！子类中调用父类构造器，必须在第一行！！！</p><ol><li>在同一个类中的构造器之间可以相互调用（重载）</li></ol><h1>对象和变量的生命周期</h1><ol><li><p>对象声明周期：</p><p>取决于引用变量的生命周期</p><p>Object is alive ( or dead ) if its reference is alive ( or dead )</p></li><li><p>变量声明周期</p><p>对基本变量和引用变量是一样的</p><p>局部变量和实例变量不同</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/pic3.png?raw=true" alt="pic"></p><p>具体来说：</p><p>局部变量，只在方法（也称为作用域scope）中存活，当方法结束，变量也会disappears</p><p>实例变量，只要对象存在，实例变量就会存活</p></li></ol><h1>局部变量的生命周期和作用域</h1><ol><li>只要它的栈帧还在栈上，（即，它所属的方法完成前）它就会存活。</li><li>作用域：只在声明它的方法中。</li><li>存活（且维持原样）但不在作用域，当它的方法调用其它方法。</li><li>一个引用变量只有在作用域才能被使用</li></ol><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/pic4.png?raw=true" alt="pic"></p><p><a href="http://t.csdnimg.cn/HS6zA">http://t.csdnimg.cn/HS6zA</a></p><h1>对象的生命周期&amp;GC</h1><ol><li><p>Java中对象是被动态分配的并且按需生成</p><ol><li>对象的内存空间是在运行时分配的，而不是编译时</li><li>new关键字为对象分配allocated内存</li></ol></li><li><p>由于是动态分配，所以内存会随着程序的运行而增加或者减少</p><ol><li>例如，在循环中创建对象，每次循环创建对象时，都会造成内存增加</li></ol></li><li><p>一旦对象的引用丢失，它就不能再恢复</p><ol><li>对象仍然会占用内存，但再也不能被程序使用</li></ol></li><li><p>Memory Leak:</p><ol><li>在C中，这是一个程序失败的经典原因</li><li>在Java中，我们不必担心，因为Java会为我们处理garbage collection</li></ol></li><li><p>只要对象存在存活的引用，那么对象就是存活的</p><ol><li>如果对象只有一个引用，并且一个持有它的栈帧从栈中弹出，那么这个对象就会被遗弃在堆中。<ol><li>这种情况下，对象符合GC条件，就会被执行GC，垃圾回收</li></ol></li><li>符合GC的对象<ol><li>程序员并不需要回收他们使用过的内存，但是必须确保对象在合适时候被抛弃</li><li>如果程序处于低内存情况，GC将会尽可能丢弃符合的变量</li></ol></li></ol><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Garbage-Collection/pic5.png?raw=true" alt="pic"></p><h1>null引用变量</h1><p>如果设置引用变量为null，那么在该null引用上使用dot操作符，就会得到运行时错误：</p><p>NullPointerException</p><p>因为这里引用为空，在对象变量处找不到一个具体的对象实例，故无法操作</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第三周-String-字符串对象</title>
    <link href="/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/"/>
    <url>/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>String不是Java中的基本类型，而是一个对象。</p><p>也有说法是String即是类也是对象：</p><p><a href="https://www.cnblogs.com/ljl666/p/ljl666.html">https://www.cnblogs.com/ljl666/p/ljl666.html</a></p><h1>创建字符串</h1><p>由String关键字创建的字符串存储在常量池中，而new创建的字符串对象存储在堆中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建，最简单的创建方式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1;                    <span class="hljs-comment">// 相同引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br></code></pre></td></tr></table></figure><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/pic1.png?raw=true" alt="pic1"><br>什么是池？常量池？</p><p><a href="https://cloud.tencent.com/developer/article/1450501">https://cloud.tencent.com/developer/article/1450501</a></p><ol><li><p>String是不可改变（immutable）的对象：出于安全性和最小化内存占用考虑</p><p>举例说明：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Google&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br><br>s = <span class="hljs-string">&quot;Runoob&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br><br><span class="hljs-comment">//输出为：</span><br><span class="hljs-comment">//Google</span><br><span class="hljs-comment">//Runoob</span><br></code></pre></td></tr></table></figure><p>从结果上来看，似乎是被改变了，那为什么还说String对象是不可变的呢？</p><p>原因是：实例中的s只是一个String对象的引用，并不是对象本身，当执行</p><p>s=”Runoob”; 创建了一个新的对象“Runoob”，而原来的“Google”还存在于内存中。</p><ol><li>这里创建的是String对象的字面值（literals），这些字面值在创建时被JVM存放在字符池（String Pool）中。</li><li>若已经内存中有一个相同字面值的String类型，那么JVM不会创建一个新的副本，（duplicate）而是新建一个对象引用，指向已有的字符串对象</li><li>Garbage Collector 不会清理String Pool.</li></ol></li></ol><p>提问：下面两个例子中打印结果是什么？</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Rabbit</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>();<br>r1.setName(“Benji”);<br><span class="hljs-type">Rabbit</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> r1;<br>r2.setName(“Blinky”); Prints:<br>System.out.println(r1.getName());<br>System.out.println(r2.getName());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Blinky<br>Blinky<br></code></pre></td></tr></table></figure><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> “Sherlock”;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1;<br>s2 = “Holmes”; Prints:<br>System.out.println(s1);<br>System.out.println(s2);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Sherlock<br>Holmes<br></code></pre></td></tr></table></figure><h1>String类</h1><h2 id="构造器：">构造器：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HelloWorld!&quot;</span>; <span class="hljs-comment">// s = “HelloWorld”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;HelloWorld!&quot;</span>); <span class="hljs-comment">// s = “HelloWorld”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(); <span class="hljs-comment">// s is an empty string</span><br><br><span class="hljs-comment">//这里比较有意思，可以用字符数组来创建新的String对象</span><br><span class="hljs-type">char</span>[] Cat_Array =&#123;<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>&#125;; <span class="hljs-comment">// like an array</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Cat_Array); <span class="hljs-comment">// s = “tigers”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Cat_Array,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// s = “ig”</span><br></code></pre></td></tr></table></figure><h2 id="方法">方法</h2><ol><li><p>int length( )：返回该String对象的字符数量，包括所有类型字符，空格等。</p></li><li><p>char charAt( int index )：返回index角标位置的字符。</p></li><li><p>返回位置：</p><ol><li>int indexOf( char ch )：返回字符ch第一次出现时的角标。</li><li>int indexOf( String str )：返回字符串str第一次出现的角标。</li><li>lastIndexOf( char ch )：返回字符ch最后一次出现的角标。</li><li>lastIndexOf( String str )：返回字符串str最后一次出现的角标。</li></ol></li><li><p>boolean equals( obj )</p></li><li><p>boolean equalsIgnoreCase( str )：判断字符串是否相同，不考虑大小写</p></li><li><p>int compareTo( str )</p><ol><li><p>比较两个字符串的字典序差值</p><p>str1.compareTo(str2)</p><p>比较二者第一次出现不同的字符的ASCLL码，用str1的减去str2的</p><p>例如：</p><p>str1=”abc”, str2=”ILoveU”</p><p>str1.compareTo(str2)为 ’a‘的ASCLL码 - ’I‘ 的ASCLL码 = 97 - 73 = 24</p></li><li><p>若二者长度不同，但前面部分完全相同，则，返回长度差值</p></li><li><p>若二者完全相同，则返回0</p></li></ol></li><li><p>substring( index1, index2 )：返回角标1到角标2之间的子串</p><p>substring( index )：返回从角标index到结束的子串</p></li><li><p>concat( s )：连接两个字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> “Hello”.concat(“World”); <span class="hljs-comment">// s = “HelloWorld”</span><br></code></pre></td></tr></table></figure></li><li><p>toUpperCase( ) / toLowerCase( )：将字符串全部转为大/小写</p></li><li><p>toString：将其他类型转为字符串，在构造新的类时，也可以重写toString方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span>;<br> <span class="hljs-type">String</span> <span class="hljs-variable">dString</span> <span class="hljs-operator">=</span> Double.toString(d);<br></code></pre></td></tr></table></figure></li><li><p>split( Sstring s )：将字符串以s为界拆分，返回一个String类型数组</p></li><li><p>void getChars( i, j, A, k )：返回字符串中角标 i到j-1的字符数组，放在数组A中，从A中角标k开始。</p></li><li><p>replace(oldCh, newCh )：将所有的oldCh换为newCh</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> “goose”.replace(‘o’,‘e’); <span class="hljs-comment">// s = “geese” </span><br></code></pre></td></tr></table></figure></li></ol><h1>StringBuffer &amp; StringBuilder 类</h1><p>当使用“+”作为字符串连接符时，Java会自动调用StringBuffer类的方法来生成新的字符串：</p><p>Example: If we write “Bugs” + “ Bunny”, Java will automatically call a StringBuffer class method to generate the string “Bugs Bunny”</p><p>老版本使用StringBuffer类，新版本用StringBuilder类</p><h1>Character类</h1><h2 id="一些静态方法">一些静态方法</h2><p>isLetter(char c) // isDigit(char c)<br>isUpperCase(char c) // isLowerCase(char c)</p><h2 id="创建对象">创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Character</span> <span class="hljs-variable">myCharacter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(‘p’);<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> myCharacter.charValue();<span class="hljs-comment">// char value wrapped in</span><br> <span class="hljs-comment">// the Character object</span><br></code></pre></td></tr></table></figure><h1>StringTokenizer类</h1><h2 id="构造器">构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">StringTokenizer(String s)<span class="hljs-comment">//默认分隔符，不会将分隔符记为token</span><br><span class="hljs-comment">//默认分隔符包括：空格，制表符，换行，回车</span><br>StringTokenizer(String s, String delimeters)<span class="hljs-comment">//传入指定分隔符，不记为token</span><br>StringTokenizer(String s, String delimiters, <span class="hljs-type">boolean</span> returnDelimiters)<span class="hljs-comment">//传入指定分隔符，可选是否记为token</span><br></code></pre></td></tr></table></figure><h2 id="使用示例">使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> “I am from Portugal.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">// Create a StringTokenizer.</span><br><span class="hljs-string">StringTokenizer myTokenizer = new StringTokenizer(s);</span><br><span class="hljs-string">System.out.println(“Number of tokens is “ + </span><br><span class="hljs-string">myTokenizer.countTokens() + “.”);</span><br><span class="hljs-string">while (myTokenizer.hasMoreTokens())</span><br><span class="hljs-string">System.out.println(myTokenizer.nextToken());</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输出</span><br>Number of tokens is <span class="hljs-number">4.</span><br>I<br>am<br>from<br>Portugal.<br></code></pre></td></tr></table></figure><p>其它示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">myTokenizer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(s, “nu”);<br><span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">myTokenizer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(s, “nu”, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>！！注意！！</p><p>这里在构造器中填入了 “nu”，作为参数，这里指的是：以”nu”中任一字符，作为分隔符，</p><p>即：遇到”n”或”u”，就分隔，而不是”nu”整体！</p><p>使用第二个构造器的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Number of tokens is <span class="hljs-number">5.</span><br>I am from Port<br>u<br>ga<br>l<br>.<br></code></pre></td></tr></table></figure><p>尝试用split( )方法编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//qnmd 不好写，懒得写了</span><br></code></pre></td></tr></table></figure><h1>例题</h1><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">stuff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(“abc,def,ghi”);<br>System.out.println(stuff.nextToken());<br></code></pre></td></tr></table></figure><p>输出：由于使用了默认分隔符构造器，而传入的字符串中不包括任何默认分隔符（空格，制表符，换行，回车）故只返回一个子串，即是原字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">abc,def,ghi<br></code></pre></td></tr></table></figure><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringTokenizer</span> <span class="hljs-variable">stuff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTokenizer</span>(“abc,def,ghi”, “,”);<br>System.out.println(stuff.nextToken());<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">abc<br></code></pre></td></tr></table></figure><h1>Scanner类</h1><p>在StringTokenizer 类中，delimiters只能是单独的字符。</p><p>而在Scanner类中，允许使用一个word指定为delimiter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> “Let your heart guide you.”;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(s);<br>myScanner.useDelimiter(“you”);<br><span class="hljs-keyword">while</span> (myScanner.hasNext())<br>System.out.println(myScanner.next());<br></code></pre></td></tr></table></figure><p>输出：使用字符串”you“作为分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Let<br>r heart guide<br>.<br></code></pre></td></tr></table></figure><h2 id="Scanner其它用法">Scanner其它用法</h2><ol><li><p>可以用来扫描基础类型：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1 10 100 1000&quot;</span>;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(s);<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (myScanner.hasNext()) &#123; sum += myScanner.nextInt(); &#125;<br>System.out.println(<span class="hljs-string">&quot;Sum = &quot;</span> + sum);<br></code></pre></td></tr></table></figure><p>使用Scanner中的诸多方法，可以用来获取字符串中的不同基本数据类型</p></li><li><p>获取命令行输入</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;Please enter an int value: &quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br></code></pre></td></tr></table></figure></li></ol><h1>格式化标识符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">% [argument_number$] [flags] [width] [.precision] type<br>String.format(“I have %,<span class="hljs-number">6.2f</span> bugs to fix”, <span class="hljs-number">12345.6789</span>);<br></code></pre></td></tr></table></figure><p>[argument_number]：如果有多个要打印的参数，可以在这里选择是第几个参数</p><p>[flags]：特殊的格式选择，例如：插入逗号，把负号放在括号里（笔者没有找到对应用法），左右对齐（左对齐：- ，默认右对齐）</p><p>[width]：输出字符的最少数量</p><p>[.precision]：十进制精度</p><p>[type]：%d %f %x %c</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第三周-Interface-接口</title>
    <link href="/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-Interface-%E6%8E%A5%E5%8F%A3/"/>
    <url>/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-Interface-%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口可以继承接口，并且可以多重继承，即一个接口可以通过extends关键字继承多个接口</p><h1>接口与类的异同点</h1><h2 id="接口与类的区别">接口与类的区别</h2><ol><li><p>接口不能用于实例化对象</p></li><li><p>接口没有构造方法</p></li><li><p>接口中的方法必须是抽象方法（JDK8以及更低版本，详情在后面讲解）</p><p>Java8之后，可以用default，static关键字来修饰非抽象方法</p></li><li><p>etc…</p></li></ol><h2 id="接口与类的相似点">接口与类的相似点</h2><ol><li>一个接口可以有多个方法</li><li>接口文件也保存在.java文件中，文件名为接口名称</li><li>etc…</li></ol><h1>关于接口中成员变量的类型：</h1><ol><li><p>默认为（public、static、final），且不能为其它类型</p></li><li><p>如何访问接口中变量？</p><p>接口名.变量名</p></li></ol><h1>关于接口中的不同类型的方法：</h1><h2 id="按访问权限分类：">按访问权限分类：</h2><ol><li><p>public &amp; 无修饰符：</p><p>无修饰符情况下，默认为public类型。</p></li><li><p>private ：</p><ol><li>私有方法，用于在接口中其它方法中使用。</li><li>必须JDK8之后的版本才能使用，JDK8以及更低版本无法使用私有方法。</li></ol></li><li><p>static：静态方法</p><ol><li>私有静态方法，在接口中其它静态方法中使用</li><li>公开静态方法，可在接口内部使用，也可以在其它任何同一包下的类中使用，通过接口名.静态方法名调用</li><li>不允许被重写</li></ol></li></ol><h2 id="按是否为抽象类分类：">按是否为抽象类分类：</h2><ol><li>abstract &amp; 无修饰符：<ol><li>无修饰符情况下，默认为abstract类型</li><li>抽象类方法，不需要写方法体</li></ol></li><li>default 关键字：<ol><li>当添加default关键字后，该方法将不再是抽象方法，可以编写该方法的方法体，你可以在实现类中，重写该方法</li><li>Java8之后增加这个关键字，主要目的是，允许开发人员在接口中增加新的功能，而不会影响已经实现了该接口的现有类。（即提供向后兼容性Provide backward compatibility for existing interfaces.）</li></ol></li></ol><h2 id="其它：">其它：</h2><ol><li><p>不存在private default关键字组合：</p><p>一旦声明为私有方法，就只能在接口内部实现，那么就必须写方法体，就不会是抽象方法，故不需要default关键字修饰</p></li><li><p>对接口中default方法重写：</p><ol><li>重写该default方法时，必须在实现类中声明是public的</li><li>而且与父类方法重写不同，重写后，在实现类中将不能再调用原本接口中的方法，父类方法重写，可以在子类中通过super关键字调用原来的方法。另外，提一句，在子接口中重写父接口方法时，可以调用父接口的同名接口，通过 父接口名.super.方法名(参数) 调用</li></ol></li><li><p>接口中default方法不能加final关键字</p></li></ol><h1>命名冲突问题</h1><p>对于一个继承了多个接口的Child接口，若Father接口和Mother接口有相同名称的方法和变量，会发生什么？</p><h2 id="方法名称相同">方法名称相同</h2><ol><li>参数不同：子接口会全部保留，类似重载</li><li>若只有返回类型不同，会报错</li><li>若两个方法完全相同<ol><li>抽象方法：会保留一个</li><li>default方法：会报错，你需要重写</li></ol></li></ol><h2 id="常量名称相同">常量名称相同</h2><p>全部保留，但用父接口名称前缀区分</p><h1>接口、实现类、父子类关系</h1><ol><li>一个子类只能extends一个父类，但可以implement多个interface</li><li>接口中可以声明接口常量，以及接口method</li><li>在实现接口的类中，需要实现接口中所有的抽象类</li><li>若父类以及实现了接口中所有抽象类，子类不再必须实现</li><li>接口是Java提供的一种多重继承（multiple inheritance）的方式</li><li>若一个类implement了接口，但没有实现接口中全部的抽象类，那么该类必须声明为抽象类</li><li>接口之间可以继承，并且支持多重继承</li></ol><h1>其它有趣问题</h1><h2 id="1-子类实现接口，接口中有方法和父类成员方法同名，到底算谁的？">1.<strong>子类实现接口，接口中有方法和父类成员方法同名，到底算谁的？</strong></h2><p><a href="http://t.csdnimg.cn/QaqiF">http://t.csdnimg.cn/QaqiF</a></p><h3 id="结论先行">结论先行</h3><p>子类实现接口，接口中有方法和父类成员方法同名时，接口调用会走子类实现，父类并不算时实现了这个接口，即接口不能指向父类对象，单子类中可以不实现这个接口，这时候走的就是父类的代码，但是父类方法必须是public的，否则编译失败。</p><h3 id="猜测的原理">猜测的原理</h3><p>子类在编译过程中会自动具有父类的protected和public接口，所以在编译过程中，子类虽然没有显示的实现该接口，但也能编译过，这也能解释为什么protected的不行，就是继承、实现接口时，子类访问权限不能低于父类权限，而interface默认接口权限为public。子类不实现的话，接口权限不满足。</p><h2 id="2-封闭类">2.封闭类</h2><p><a href="http://t.csdnimg.cn/XRQL6">http://t.csdnimg.cn/XRQL6</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第三周-GUI</title>
    <link href="/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-GUI/"/>
    <url>/henry.github.io/2024/06/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-GUI/</url>
    
    <content type="html"><![CDATA[<h1>GUI编程的三个主要概念</h1><ol><li>Component：用户能看到的能交互的对象</li><li>Container：可以放其它component的component</li><li>Event：由用户触发的action</li></ol><h1>设计GUI大致包括：</h1><ol><li>创建components</li><li>放入containers</li><li>编写程序以响应对应事件</li></ol><h1>基本框架示例</h1><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-GUI/pic1.png?raw=true" alt="pic1"></p><p>一个简单的完整的JavaGUI应用程序如图所示，其基本结构如下：</p><ol><li>一个顶层的容器——Frame，用于呈现GUI所有内容</li><li>次级容器，主要是Panel类，用于放置各种组件component，通过设置布局属性来调整组件位置</li><li>组件component，包括但不限于按钮，标签，输入框。</li></ol><h1>Java中的容器和组件</h1><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-GUI/pic2.png?raw=true" alt="pic2"></p><p>在本轮学习中，没有涉及到JApplet类，详情见：</p><p><a href="https://www.runoob.com/java/java-applet-basics.html">https://www.runoob.com/java/java-applet-basics.html</a></p><h1>搭建一个基本的GUI步骤</h1><ol><li>创建框架实例</li><li>创建组件</li><li>将组件加入到框架中</li><li>调整框架尺寸等参数，并设置为可见</li></ol><h2 id="代码及实例">代码及实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JFrame</span> <span class="hljs-variable">myFrame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>();<br><span class="hljs-type">JButton</span> <span class="hljs-variable">myButton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;Click me&quot;</span>);<br>myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>myFrame.getContentPane().add(myButton);<br>myFrame.setSize(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>myFrame.setVisible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>提问：为什么要调用getContentPane()方法？</p><p>回答：</p><p>对于一个JFrame对象，它只是我们的一个外部窗口实例，如果我们想要在这个窗口框架中添加组件进去，就必须获取到这个框架中的面板对象，才可以在这个面板对象中添加组件。</p><p>JFrame的实例调用getContentPane()方法时，会返回一个Container实例，这个实例是通过获取根面板后，再获取根面板的内容面板得来的，以下是对应的方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JFrame中 getContentPane()方法</span><br><span class="hljs-keyword">public</span> Container <span class="hljs-title function_">getContentPane</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getRootPane().getContentPane();<br>&#125;<br><span class="hljs-comment">//JFrame中 JRootPane()方法</span><br><span class="hljs-keyword">public</span> JRootPane <span class="hljs-title function_">getRootPane</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> rootPane;<br>&#125;<br><span class="hljs-comment">//JFrame中 rootPane对象</span><br><span class="hljs-keyword">protected</span> JRootPane rootPane;<br><span class="hljs-comment">//JRootPane中 getContentPane()方法</span><br><span class="hljs-keyword">public</span> Container <span class="hljs-title function_">getContentPane</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> contentPane; &#125;<br><span class="hljs-comment">//JRootPane中 contentPane对象</span><br><span class="hljs-keyword">protected</span> Container contentPane;<br></code></pre></td></tr></table></figure><h1>容器分类</h1><h2 id="Top-level-Containers">Top-level Containers:</h2><p>JFrame，JDialog等</p><p>在Swing应用中，至少要有一个此类容器，才能呈现内容</p><h2 id="General-purpose-Containers">General-purpose Containers:</h2><p>JPanel，JScrollPane</p><h1>JFrame</h1><p>最常用的容器类</p><h2 id="一-新建JFrame对象">一.新建JFrame对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>()创建没有标题的窗口<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(String s)创建标题为s的窗口<br></code></pre></td></tr></table></figure><h2 id="二-设置JFrame参数">二.设置JFrame参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTitle</span><span class="hljs-params">(String title)</span><span class="hljs-comment">//设置窗口标题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span><span class="hljs-comment">//设置窗口的大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVisible</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span><span class="hljs-comment">//设置窗口是否可见，窗口默认是不可见的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLocation</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//设置窗口的位置，默认位置是(0,0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBound</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span><span class="hljs-comment">//设置窗口的初始位置是(x,y),窗口宽为width，高为height</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResizable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span><span class="hljs-comment">//设置窗口是否可调整大小，默认可调整大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispose</span><span class="hljs-params">()</span><span class="hljs-comment">//撤销当前窗口，并释放当前窗口所使用的资源</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">settExtendState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span><span class="hljs-comment">//设置窗口的扩展状态，其中参数state取JFrame类中的下列类常量：</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">MAXIMIZED_HORIZ水平方向最大化</span><br><span class="hljs-comment">MAXIMIZED_VERT垂直方向最大化</span><br><span class="hljs-comment">MAXIMIZED_BOTH水平、垂直方向都最大化</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="三-设定JFrame的关闭方式">三.设定JFrame的关闭方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">setDefaultCloseOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> operation)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎么样的处理，</span><br><span class="hljs-comment">其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理：</span><br><span class="hljs-comment">DO_NOTHING_ON_CLOSE 什么都不做</span><br><span class="hljs-comment">HIDE_ON_CLOSE 隐藏当前窗口</span><br><span class="hljs-comment">DISPOSE_ON_CLOSE 隐藏当前窗口，并释放窗体占有的其他资源</span><br><span class="hljs-comment">EXIT_ON_CLOSE 结束窗口所在的应用程序</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1>常见组件</h1><p>JButton, JList, JCheckBox, JTextField, JRadioButton</p><h1>事件驱动式编程</h1><h2 id="名词区分">名词区分</h2><p><strong>事件：</strong> 指的是鼠标点击，键盘输入等用户操作。其本身就是一个对象。</p><p><strong>事件对象</strong>：事件发生后，在flex中就称为事件对象，事件对象有针对其的侦听器，事件对象有其属性，比如：target。</p><p><strong>事件发生的对象</strong>：指事件源。</p><p><strong>事件源</strong>：发生事件的对象，一般指某一具体的组件，比如：用户点击某Button，则此Button即为事件源。</p><p><strong>侦听器</strong>：是一个方法，用以响应事件。</p><h2 id="三要素">三要素</h2><ol><li><p>事件源：event source</p><p>产生事件的对象，按钮，菜单等组件</p></li><li><p>事件对象：</p><p>封装事件信息的对象，包括事件类型，事件源等</p></li><li><p>事件监听器：</p><p>负责监听特定类型的事件，并在事件发生时执行相应的回调处理函数</p></li></ol><h2 id="事件处理流程">事件处理流程</h2><ol><li>注册事件监听器：注册到事件源上，以便监听特定组件</li><li>事件触发：用户操作或者系统触发事件源，产生相应的事件对象</li><li>事件分发：事件源将事件对象传递给注册的监听器</li><li>事件处理：监听器调用对应的事件处理方法</li></ol><p>事件处理方法命名：一般是 事件源+Done</p><p>如：mouseClicked(MouseEvent e)</p><h1>Layout布局</h1><p><a href="http://t.csdnimg.cn/t1oP7">http://t.csdnimg.cn/t1oP7</a></p><p>std JDK提供五种类以供实现布局管理</p><p><img src="https://github.com/jhr419/henry.github.io/blob/master/img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E5%91%A8-GUI/pic3.png?raw=true" alt="pic3"></p><ul><li>FlowLayout</li><li>GridLayout</li><li>BorderLayout</li><li>CardLayout</li><li>GridBagLayout</li></ul><p>不讨论后面两种</p><h2 id="在容器内改变布局">在容器内改变布局</h2><ol><li><p>创建容器时：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JPanel</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>);<br></code></pre></td></tr></table></figure><p>FlowLayout( )参数：</p><ol><li><p>空参数</p></li><li><p>(int align)：设置对齐方式</p><p>FlowLayout.LEFT</p><p>FlowLayout.CENTER</p><p>FlowLayout.RIGHT</p></li><li><p>(int align, int hgap, int vgap)：对齐方式，水平、垂直间隙</p></li></ol><p>GridLayout( )参数：</p><ol><li>空参数：默认一列</li><li>(int rows, int cols)：当为0时，该方向上为默认布局</li><li>(int rows, int cols, int hgap, int vgap)</li></ol><p>BorderLayout( )：</p><p>使用方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">myFrame.getContentPane().add(myButton);<br>myFrame.getContentPane().add(BorderLayout.CENTER, myButton);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">参数，东西南北中</span><br><span class="hljs-comment">BorderLayout.EAST</span><br><span class="hljs-comment">BorderLayout.WEST</span><br><span class="hljs-comment">BorderLayout.SOUTH</span><br><span class="hljs-comment">BorderLayout.NORTH</span><br><span class="hljs-comment">BorderLayout.CENTER</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h1>本章节用到的方法汇总</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>()<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(String s)<br><span class="hljs-type">JButton</span> <span class="hljs-variable">myButton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(“Click me”);<br>myFrame.getContentPane().add(myButton);<br>myFrame.setSize(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>myFrame.setVisible(<span class="hljs-literal">true</span>);<br>myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><span class="hljs-type">JLabel</span> <span class="hljs-variable">myLabel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(“text”, JLabel.RIGHT);<br><span class="hljs-type">JPanel</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>p.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>FlowLayout()<br>FlowLayout(<span class="hljs-type">int</span> align)<br>FlowLayout(<span class="hljs-type">int</span> align, <span class="hljs-type">int</span> hgap, <span class="hljs-type">int</span> vgap)<br>frame.pack();<span class="hljs-comment">//将窗口大小设置为最佳大小  即相当于调用了：setSize(f.getPreferredSize());</span><br>myFrame.getContentPane().add(BorderLayout.CENTER, myButton);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第四周-Exception Handling 异常处理</title>
    <link href="/henry.github.io/2024/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Exception-Handling-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/henry.github.io/2024/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Exception-Handling-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>Run-Time Error Handling</h1><p>错误类型：</p><ol><li><p>系统自动抛出的异常</p><p>所有系统定义的编译和运行异常都可以由系统自动抛出，称为标准异常</p></li><li><p>语句抛出的异常<br>用户程序自定义的异常和应用程序特定的异常，必须借助throws 和 throw 语句来定义抛出异常。</p></li></ol><p>具体来说，有很多种不同的异常可能出现：</p><p>用户输入了非法数据，要打开的文件不存在或者没有权限，网络通信时连接中断，或者JVM内存溢出</p><h2 id="三种类型的异常">三种类型的异常</h2><ol><li><p>检查性异常</p><p>最具代表的检查性异常是<strong>用户错误或问题</strong>引起的异常，这些异常在编译时强制要求程序员处理。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>这类异常通常使用 <strong>try-catch</strong> 块来捕获并处理异常，或者在方法声明中使用 <strong>throws</strong> 子句声明方法可能抛出的异常。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-comment">// 处理异常的代码</span><br>&#125;<br><span class="hljs-comment">//or或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 可能会抛出IOException的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行时异常</p><p>这些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>    <span class="hljs-comment">// 处理异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>错误</p><p>错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p></li></ol><p>要么尝试捕获运行时错误，要么就是尝试声明不要捕获。</p><p>Java提供了以下的关键字来支持异常处理：</p><ul><li><strong>try</strong>：用于包裹可能会抛出异常的代码块。</li><li><strong>catch</strong>：用于捕获异常并处理异常的代码块。</li><li><strong>finally</strong>：用于包含无论是否发生异常都需要执行的代码块。</li><li><strong>throw</strong>：用于手动抛出异常。</li><li><strong>throws</strong>：用于在方法声明中指定方法可能抛出的异常。</li><li><strong>Exception</strong>类：是所有异常类的父类，它提供了一些方法来获取异常信息，如 <strong>getMessage()、printStackTrace()</strong> 等。</li></ul><h2 id="怎么处理异常？">怎么处理异常？</h2><h3 id="2-1JVM默认处理异常的方式">2.1JVM默认处理异常的方式</h3><ol><li>如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤：</li></ol><ul><li>把异常的名称，错误原因及异常出现的位置等信息输出在了控制台</li><li>程序停止执行</li></ul><h3 id="2-2try-catch方式">2.2try-catch方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>可能出现异常的代码; <br>&#125; <span class="hljs-keyword">catch</span>(异常类名 变量名) &#123;<br> 异常的处理代码; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行流程</li></ul><ol><li>程序从 try 里面的代码开始执行</li><li>出现异常，就会跳转到对应的 catch 里面去执行，进行处理</li><li>执行完毕之后，程序还可以继续往下执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo01</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>); method(); <br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>); <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <br>System.out.println(arr[<span class="hljs-number">3</span>]); <br>System.out.println(<span class="hljs-string">&quot;这里能够访问到吗&quot;</span>); <br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <br><span class="hljs-comment">// System.out.println(&quot;你访问的数组索引不存在，请回去修改为正确的索引&quot;); </span><br>e.printStackTrace(); <br>&#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3throw方式">2.3throw方式</h3><p><strong>throw</strong> 关键字用于在当前方法中抛出一个异常。</p><p>通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态。</p><p>即：当程序运行不满足程序员要求的格式时，可以使用throw抛出异常，</p><h2 id="throws和throw的区别">throws和throw的区别</h2><h3 id="throws">throws</h3><p>用在方法声明后面，跟的是异常类名<br>表示抛出异常，由该方法的调用者来处理<br>表示出现异常的一种可能性，并不一定会发生这些异常</p><h3 id="throw">throw</h3><p>用在方法体内，跟的是异常对象名<br>表示抛出异常，由方法体内的语句处理<br>执行 throw 一定抛出了某种异常</p><p>总结：</p><ol><li>throw 是语句抛出一个异常；throws 是方法抛出一个异常；</li><li>throw语法：throw &lt;异常对象&gt;</li><li>throws语法：[&lt;修饰符&gt;]&lt;返回值类型&gt;&lt;方法名&gt;（[&lt;参数列表&gt;]）[throws&lt;异常类&gt;]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 调用声明抛出 Checked 异常的方法，要么显式捕获该异常</span><br><span class="hljs-comment">// 要么在 main 方法中再次声明抛出</span><br>throwChecked(-<span class="hljs-number">3</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(e.getMessage());<br>&#125;<br><span class="hljs-comment">// 调用声明抛出 Runtime 异常的方法既可以显式捕获该异常</span><br><span class="hljs-comment">// 也可不理会该异常</span><br>throwRuntime(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwChecked</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//自行抛出 Exception 异常</span><br><span class="hljs-comment">//该代码必须处于 try 块里，或处于带 throws 声明的方法中</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;a 的值大于 0，不符合要求&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwRuntime</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br><span class="hljs-keyword">if</span>( a &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 自行抛出 RuntimeException 异常，既可以显式捕获该异常</span><br><span class="hljs-comment">// 也可完全不理会该异常，把该异常交给该方法调用者处理</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;a 的值大于 0，不符合要求&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么要抛出异常，什么时候抛出异常？">为什么要抛出异常，什么时候抛出异常？</h3><ul><li>为什么要捕获异常？<br>编译时程序可能会出现异常，如果出现异常程序就会中断，但是如果捕获异常，做出处理，程序就可以运行下去</li><li>抛出异常和捕获异常的区别？</li></ul><ol><li>抛出异常：没有办法将具体的异常打印出来，不做任何处理；程序中断。</li><li>捕获异常：如果程序出现了异常，就能够详细的打印什么原因导致了异常，并且能够做出相应的处理，显示详细的日志，程序不会中断。</li></ol><h2 id="再详说try-catch-块">再详说try/catch 块</h2><ol><li><p>当程序运行，JVM会尝试执行try块中所有语句，</p><p>若其中某个语句throws an exception，那么：</p><p>对应的catch块将被执行，</p><p>或者，</p><p>该代码所在的方法本身将会抛出异常</p></li><li><p>try/catch块后面，也会有finally块，通常用于做异常处理之后的最后工作，例如关闭文件等</p></li></ol><h3 id="try-catch-finally块语法">try/catch/finally块语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//会抛出异常的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span>(E1 e1)&#123;<br><span class="hljs-comment">//处理E1的代码</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">catch</span>(En en)&#123;<br><span class="hljs-comment">//处理En的代码</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//code to tidy up: close files, etc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个try代码块后面跟随有多个catch，这种情况叫做多重捕获：</p><p>保护代码中发生异常，异常会被抛给第一个catch块。</p><p>如果抛出异常的数据类型与E1匹配，那么该异常在这里就会被捕获。</p><p>如果不匹配，就会传递给下一个catch块，</p><p>如此，直到异常被捕获或者通过所有的catch块</p><p>try-catch的模式，导致局部变量可以没有初始化，也正常存在，异常被捕获，但是不做对应初始化的操作，程序也不会退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> foo;<br><span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-comment">// ...</span><br> foo = getResults();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// ... &#125;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> foo; <span class="hljs-comment">// HERE!</span><br><br><span class="hljs-comment">//Partial solution:</span><br><span class="hljs-type">int</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-comment">// ...</span><br> foo = getResults();<br> <span class="hljs-type">int</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> foo;<br> <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">// ... &#125;</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>所有抛出异常的代码块，必须包含在一个抛出异常的方法中吗？</p><p>不是的，对于检查异常（checked exception），必须在方法签名中声明，使用’throws‘关键字，这些异常是程序正常运行中可以预见的异常。对于非检查异常（unchecked exception）不需要在方法签名中声明，也不需要强制捕获处理。</p><h1>Creating Exception Classes</h1><p>可以创建自己的异常类，可以像正常的类一样使用，但是必须继承Exception类，要在构造器中调用父类的构造器。</p><p>自定义异常类，可以在该自定义异常类中对异常警告进行自定义。</p><h2 id="Understanding-Stack-Trace-Messages">Understanding Stack Trace Messages</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>statement1;<br>statement2;<br>statement3;<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception1 ex1) &#123; &#125;<br><span class="hljs-keyword">catch</span> (Exception2 ex2) &#123; &#125;<br>statement4;<br></code></pre></td></tr></table></figure><p>这段代码中，假设s2会造成异常，请问：</p><ol><li><p>s3会执行吗？</p></li><li><p>如果异常没有被捕获，s4会执行吗？</p></li><li><p>异常被其中一个catch捕获，s4会执行吗？</p></li></ol><p>答案：</p><ul><li><code>statement3</code>不会执行，s2抛出异常后，会直接跳转到catch块中</li><li>如果<code>try</code>块中的异常没有被<code>catch</code>块捕获，<code>statement4</code>不会执行。</li><li>如果<code>try</code>块中的异常被某个<code>catch</code>块捕获并处理，<code>statement4</code>会执行。</li></ul><p>为什么没有被catch捕获s4就不会执行？</p><p>在Java中，如果一个异常没有被捕获并处理，程序的正常控制流会被中断，异常会沿着调用栈向上传播，直到被某个合适的异常处理程序捕获或者导致程序终止。这就是为什么没有被捕获的异常会导致<code>statement4</code>不执行的原因。具体原因如下：</p><h3 id="异常传播机制"><strong>异常传播机制</strong></h3><ol><li><strong>异常抛出</strong>：当在<code>try</code><strong>块中抛出一个异常时，程序会立即停止执行</strong><code>try</code><strong>块中的剩余代码。</strong></li><li><strong>寻找处理程序</strong>：<strong>程序会检查是否有与抛出异常类型匹配的</strong><code>catch</code><strong>块。如果找到一个匹配的</strong><code>catch</code><strong>块，控制流会转移到这个</strong><code>catch</code><strong>块，并执行其中的代码。</strong></li><li><strong>未匹配处理程序</strong>：<strong>如果没有找到匹配的</strong><code>catch</code><strong>块，异常会沿着调用栈向上传播。传播过程会一直持续到找到合适的异常处理程序或最终到达Java虚拟机（JVM）。</strong></li><li><strong>程序终止</strong>：<strong>如果异常传播到JVM而没有被捕获，JVM会终止程序，并打印异常的堆栈跟踪信息。</strong></li></ol><h3 id="示例代码分析"><strong>示例代码分析</strong></h3><p>让我们用示例代码详细说明这一过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<br><span class="hljs-keyword">try</span> &#123;<br>    statement1;<br>    statement2;<br>    statement3;<br>&#125; <span class="hljs-keyword">catch</span> (Exception1 ex1) &#123;<br>    <span class="hljs-comment">// 处理Exception1</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception2 ex2) &#123;<br>    <span class="hljs-comment">// 处理Exception2</span><br>&#125;<br>statement4;<br><br></code></pre></td></tr></table></figure><p>假设在<code>try</code>块中抛出了一个未被捕获的异常：</p><ol><li><strong>异常抛出前</strong>：<code>statement1</code>和<code>statement2</code>顺利执行。</li><li><strong>异常抛出</strong>：<code>statement3</code>抛出了<code>Exception3</code>，而<code>Exception3</code>没有匹配的<code>catch</code>块。</li><li><strong>控制流中断</strong>：由于没有匹配的<code>catch</code>块，异常沿着调用栈向上传播。<code>try</code>块中的剩余代码（包括<code>statement3</code>之后的代码）不会执行。</li><li><strong>异常传播到调用者</strong>：如果当前方法没有处理异常，异常会继续向上传播到调用该方法的地方。</li><li><strong>JVM处理异常</strong>：如果异常最终传播到JVM，程序会终止，<code>statement4</code>永远不会执行。</li></ol><h3 id="捕获异常的情况"><strong>捕获异常的情况</strong></h3><p>当异常被捕获时，程序的控制流如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<br><span class="hljs-keyword">try</span> &#123;<br>    statement1;<br>    statement2;<br>    statement3;<br>&#125; <span class="hljs-keyword">catch</span> (Exception1 ex1) &#123;<br>    <span class="hljs-comment">// 处理Exception1</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception2 ex2) &#123;<br>    <span class="hljs-comment">// 处理Exception2</span><br>&#125;<br>statement4;<br><br></code></pre></td></tr></table></figure><p>假设**<code>statement3</code>抛出了一个被捕获的<code>Exception1</code>：</p><ol><li><strong>异常抛出前</strong>：<code>statement1</code>和<code>statement2</code>顺利执行。</li><li><strong>异常抛出</strong>：<code>statement3</code>抛出<code>Exception1</code>。</li><li><strong>控制流转移</strong>：程序找到匹配的<code>catch (Exception1 ex1)</code>块，控制流转移到该块并执行处理代码。</li><li><strong>异常处理后</strong>：<code>catch</code>块执行完后，程序继续执行<code>try-catch</code>块后的代码。</li><li><strong>继续执行</strong>：<code>statement4</code>会执行，因为异常已被处理。</li></ol><h3 id="总结"><strong>总结</strong></h3><ul><li><strong>未捕获异常</strong>：导致控制流中断，程序终止，<code>statement4</code>不执行。</li><li><strong>捕获异常</strong>：异常被处理后，程序继续执行，<code>statement4</code>会执行。</li></ul><p>这种行为确保异常处理的集中和清晰，同时避免程序在未处理异常情况下继续执行，可能导致不可预测的行为和错误。</p><h1>Assertions断言</h1><p><a href="http://t.csdnimg.cn/quJMl">http://t.csdnimg.cn/quJMl</a></p><p>断言，是一种有效检查和调试的工具，通过断言，我们可以验证程序的逻辑和假设，确保程序在运行时达到预期的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AssertionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> x &gt; <span class="hljs-number">0</span> : <span class="hljs-string">&quot;x必须大于0&quot;</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;断言通过&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>断言条件，x&gt;0，如果不满足就会触发断言错误，抛出AssertionError异常。如果满足，将会输出“断言通过“的信息</p><h2 id="启用和禁用断言">启用和禁用断言</h2><p>默认情况下，JVM会禁用断言功能</p><p>启用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java -ea AssertionExample<span class="hljs-comment">//在命令行中输入，后面是类名</span><br>java -ea <span class="hljs-keyword">package</span> class<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>你必须先编译java文件后再启用断言</p><p>并且必须通过命令行来直接执行断言判断，运行java类是无效的</p><p>禁用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java -da AssertionExample<br>java -da <span class="hljs-keyword">package</span> class<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记—第四周—Number课件</title>
    <link href="/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/"/>
    <url>/henry.github.io/2024/06/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E5%9B%9B%E5%91%A8-Number%E8%AF%BE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1>final关键字</h1><ol><li>有时候我们不希望子类重写父类中的方法，或者改变父类中的变量，可以使用final关键字，将其变为常量。</li><li>也可以在创建类的时候，在class关键字前加入final关键字，这样这个类就无法被extend</li><li>一般一个static final 变量名要大写，表明身份。</li><li>final变量要在声明时初始化，或者在构造器中初始化。</li><li>final类和抽象类是不同的：final类不能被继承，抽象类不能被实例化。</li></ol><h1>static关键字</h1><p>参考文章：<br><a href="https://blog.csdn.net/sophia__yu/article/details/83578934">https://blog.csdn.net/sophia__yu/article/details/83578934</a></p><ol><li><p>static变量，一般也称为类变量（class variable），具有static关键字的成员，一般在类被创建的时候就会建立一块内存区域，独属于类的内存，该类和其子类共同访问这块内存。</p><p>在类中，非static成员，一般在实例化时，会建立这些成员的副本，各实例自己管理该副本。</p><p>而static成员，所有类实例都会访问。</p><p>任意实例在改变这个静态成员时，所有对象对应的该成员都会被改变</p></li><li><p>static方法中只能使用static变量或者static方法，非static方法可以使用static成员</p></li><li><p>static还可以用于代码块，随类一同被建立</p></li><li><p>所有static修饰的内容，在类被创建时，同时建立</p></li><li><p>static无法应用于构造器，静态属于类，构造器属于对象<br>参考文章：<br><a href="https://www.cnblogs.com/java-friend/p/11750671.html">https://www.cnblogs.com/java-friend/p/11750671.html</a></p></li><li><p>通常我们可以同时使用static和final来修饰一个常量，所有对象都可以访问，并且无法修改常量</p></li></ol><h2 id="Math类">Math类</h2><ol><li>public final class Math，可以看到Math类是final的，无法被修改。</li><li>private Math( )，它的构造器是私有的，所以无法被实例化。</li><li>Math类中所有成员，包括所有变量和方法，都是static的。</li></ol><p><strong>提问：哪些类不能被实例化？</strong></p><p><strong>答案：抽象类，接口，具有private构造器的类。</strong></p><ol><li>Abstract classes and interfaces.</li><li>Classes with private constructors</li></ol><h1>Wrapper Classes包装类</h1><ol><li>包装类，当基本类型需要被当作对象使用时。</li><li>每个基本类型都有对应的包装类。</li><li>两个名字与基本类型不同的包装类：Integer, Character。</li></ol><h2 id="Autoboxing-自动包装">Autoboxing 自动包装</h2><p>待更新</p><h2 id="Static-Method-in-Wrappers">Static Method in Wrappers</h2><p>Wrappers有一些可以转换的方法：</p><p>接收字符串类型，返回一个特定的基本类型：</p><p>布尔类型与其它类型十分不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-type">Strign</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str1);<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Double.parseDouble(str2);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(str3).booleanValue();<br></code></pre></td></tr></table></figure><p>以下这种情况，可以被编译，但无法运行，会报错：NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">anotherStr</span> <span class="hljs-operator">=</span> “ten”;<br><span class="hljs-type">int</span> <span class="hljs-variable">anotherInt</span> <span class="hljs-operator">=</span> Integer.parseInt(anotherStr);<br></code></pre></td></tr></table></figure><h2 id="Static-Imports">Static Imports</h2><p>当import某些包时，你也可以使用static关键字进行import，这样做后，使用包中类可以省类名，默认使用类中的成员，但会使得代码难以理解，无法辨认1成员出自哪些类：</p><p>待更新</p><h2 id="Wrapper-Classes-and-Number">Wrapper Classes and Number</h2><p>所有的包装类都是Number抽象类的子类，你可以构造一个Number对象，放入一个包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="一些其它常见问题">一些其它常见问题</h2><ol><li><p>什么时候使用包装类、number类，而不是基本数据类型？</p><ol><li>当方法期待一个对象参数时，通常用于处理数字集合。</li><li>当我们希望数值处为null时，只有当其为对象时，才可以为null，如果是基本数据类型，则一般为默认值。</li></ol></li><li><p>Number子类，即包装类，有一些常量，用来表示该数据类型的最大最小值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Long.MIN_VALUE); → –<span class="hljs-number">2</span>^<span class="hljs-number">63</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用class method to convert values to/from other primitive types, to/from strings，并且可以在不同数制下转换：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toHexString(i);<br></code></pre></td></tr></table></figure></li><li><p>Which of these classes define immutable objects?<br>Character<br>Byte<br>Short<br>Object</p></li></ol><p>immutable objects：不可变的对象，实际上就是final类型</p><p>这几个中，包装类都是final类型</p><h2 id="包装类的常用方法">包装类的常用方法</h2><p>参考文章：<br><a href="http://t.csdnimg.cn/Waffj">http://t.csdnimg.cn/Waffj</a></p><h1>Recursion递归</h1><h2 id="Java递归方法中两个重要部分">Java递归方法中两个重要部分</h2><h3 id="Base-Case">Base Case</h3><p>Base Case是递归停止的条件，标明了递归的最简单情况，base case避免了无穷递归的情况。</p><h3 id="Recursive-Case">Recursive Case</h3><p>recursive case是method的一部分，是method调用自己的部分。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
